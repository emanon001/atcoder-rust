{
  "ALL_DIRS": {
    "prefix": "ALL_DIRS",
    "body": [
      "/// 上下左右 + 斜め (i, j)",
      "pub const ALL_DIRS: [(isize, isize); 8] = [",
      "    (-1, 0),",
      "    (-1, 1),",
      "    (0, 1),",
      "    (1, 1),",
      "    (1, 0),",
      "    (1, -1),",
      "    (0, -1),",
      "    (-1, -1),",
      "];"
    ]
  },
  "BinarySearchOk": {
    "prefix": "BinarySearchOk",
    "body": [
      "pub trait BinarySearchOk<T>: PartialEq + Copy {",
      "    fn bs_needs_next_search(&self, ng: &T) -> bool;",
      "    fn bs_mid_value(&self, ng: &T) -> Self;",
      "    fn bs_into(&self) -> T;",
      "}"
    ]
  },
  "UDLR_DIRS": {
    "prefix": "UDLR_DIRS",
    "body": [
      "/// 上下左右 (i, j)",
      "pub const UDLR_DIRS: [(isize, isize); 4] = [(-1, 0), (1, 0), (0, -1), (0, 1)];"
    ]
  },
  "ascii_chars": {
    "prefix": "ascii_chars",
    "body": [
      "pub fn make_ascii_lowercase_chars() -> Vec<char> {",
      "    let base = 0x61;",
      "    make_chars(base..base + 26)",
      "}",
      "pub fn make_ascii_uppercase_chars() -> Vec<char> {",
      "    let base = 0x41;",
      "    make_chars(base..base + 26)",
      "}",
      "fn make_chars(range: std::ops::Range<u8>) -> Vec<char> {",
      "    range.into_iter().map(char::from).collect::<Vec<_>>()",
      "}",
      "pub fn rotate_ascii_lowercase_char(ch: char, n: isize) -> char {",
      "    assert!(ch.is_ascii_lowercase());",
      "    rotate_char(ch, n, 0x61, 26)",
      "}",
      "pub fn rotate_ascii_uppercase_char(ch: char, n: isize) -> char {",
      "    assert!(ch.is_ascii_uppercase());",
      "    rotate_char(ch, n, 0x41, 26)",
      "}",
      "fn rotate_char(ch: char, n: isize, base: u8, m: u8) -> char {",
      "    let m = m as isize;",
      "    let ch_pos = ch as u8 - base;",
      "    let offset = if n >= 0 {",
      "        (ch_pos as isize + n) % m",
      "    } else {",
      "        (m - (ch_pos as isize - n.abs()).abs() % m) % m",
      "    } as u8;",
      "    char::from(base + offset)",
      "}"
    ]
  },
  "balanced_ternary": {
    "prefix": "balanced_ternary",
    "body": [
      "pub fn balanced_ternary(n: i64) -> Vec<i64> {",
      "    let mut res = VecDeque::new();",
      "    let mut n = n;",
      "    while n != 0 {",
      "        let m = (n % 3 + 3) % 3;",
      "        match m % 3 {",
      "            0 => res.push_front(0),",
      "            1 => {",
      "                res.push_front(1);",
      "                n -= 1;",
      "            }",
      "            2 => {",
      "                res.push_front(-1);",
      "                n += 1;",
      "            }",
      "            _ => unreachable!(),",
      "        };",
      "        n /= 3;",
      "    }",
      "    res.into_iter().collect()",
      "}"
    ]
  },
  "bellman_ford": {
    "prefix": "bellman_ford",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn bellman_ford(&self, s: usize) -> Option<Vec<Option<Cost>>> {",
      "        let vc = self.vc;",
      "        let mut cost_list = vec![self.inf; vc];",
      "        cost_list[s] = Cost::zero();",
      "        for c in 0..vc {",
      "            for u in 0..vc {",
      "                for &(v, w) in &self.graph[u] {",
      "                    if cost_list[u] == self.inf {",
      "                        continue;",
      "                    }",
      "                    let new_cost = cost_list[u] + w;",
      "                    if new_cost < cost_list[v] {",
      "                        cost_list[v] = new_cost;",
      "                        if c == vc - 1 {",
      "                            return None;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        Some(self.optionalize(cost_list))",
      "    }",
      "}"
    ]
  },
  "bit": {
    "prefix": "bit",
    "body": [
      "/// `T` is numeric only",
      "pub struct Bit<T>",
      "where",
      "    T: std::ops::AddAssign + std::ops::SubAssign + std::ops::Sub<Output = T> + num::Zero + Clone,",
      "{",
      "    n: usize,",
      "    data: Vec<T>,",
      "}",
      "/// 0-origin",
      "/// [0, n)",
      "impl<T> Bit<T>",
      "where",
      "    T: std::ops::AddAssign + std::ops::SubAssign + std::ops::Sub<Output = T> + num::Zero + Clone,",
      "{",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            n,",
      "            data: vec![T::zero(); n + 1],",
      "        }",
      "    }",
      "    /// 0-origin",
      "    pub fn add(&mut self, i: usize, x: T) {",
      "        if i >= self.n {",
      "            panic!();",
      "        }",
      "        let mut i = i + 1;",
      "        while i <= self.n {",
      "            self.data[i] += x.clone();",
      "            i += ((i as isize) & -(i as isize)) as usize;",
      "        }",
      "    }",
      "    /// 0-origin",
      "    pub fn sub(&mut self, i: usize, x: T) {",
      "        if i >= self.n {",
      "            panic!();",
      "        }",
      "        let mut i = i + 1;",
      "        while i <= self.n {",
      "            self.data[i] -= x.clone();",
      "            i += ((i as isize) & -(i as isize)) as usize;",
      "        }",
      "    }",
      "    /// [0, i)",
      "    pub fn sum(&self, i: usize) -> T {",
      "        if i > self.n {",
      "            panic!();",
      "        }",
      "        let mut i = i;",
      "        let mut res = T::zero();",
      "        while i > 0 {",
      "            res += self.data[i].clone();",
      "            i -= ((i as isize) & -(i as isize)) as usize;",
      "        }",
      "        res",
      "    }",
      "    /// [i, j)",
      "    pub fn range_sum(&self, i: usize, j: usize) -> T {",
      "        if i > self.n || j > self.n {",
      "            panic!();",
      "        }",
      "        if i >= j {",
      "            return T::zero();",
      "        }",
      "        self.sum(j) - self.sum(i)",
      "    }",
      "}"
    ]
  },
  "bit_dp": {
    "prefix": "bit_dp",
    "body": [
      "pub fn bit_dp<C>(",
      "    state: usize,",
      "    dp: &mut [Option<i64>],",
      "    candidates: &[C],",
      "    fin: usize,",
      "    inf: i64,",
      "    f: fn(usize, &C) -> (usize, i64),",
      ") -> i64 {",
      "    if let Some(res) = dp[state] {",
      "        return res;",
      "    }",
      "    if state == fin {",
      "        let res = 0;",
      "        dp[state] = Some(res);",
      "        return res;",
      "    }",
      "    let mut res = inf;",
      "    for c in candidates {",
      "        let (new_state, cost) = f(state, c);",
      "        if new_state != state {",
      "            let cost = bit_dp(new_state, dp, candidates, fin, inf, f) + cost;",
      "            res = res.min(cost);",
      "        }",
      "    }",
      "    dp[state] = Some(res);",
      "    res",
      "}"
    ]
  },
  "bsearch": {
    "prefix": "bsearch",
    "body": [
      "pub trait BinarySearchOk<T>: PartialEq + Copy {",
      "    fn bs_needs_next_search(&self, ng: &T) -> bool;",
      "    fn bs_mid_value(&self, ng: &T) -> Self;",
      "    fn bs_into(&self) -> T;",
      "}",
      "impl BinarySearchOk<i64> for i64 {",
      "    fn bs_needs_next_search(&self, ng: &Self) -> bool {",
      "        (self - ng).abs() > 1",
      "    }",
      "    fn bs_mid_value(&self, ng: &Self) -> Self {",
      "        (self + ng) / 2",
      "    }",
      "    fn bs_into(&self) -> Self {",
      "        *self",
      "    }",
      "}",
      "impl BinarySearchOk<i128> for i128 {",
      "    fn bs_needs_next_search(&self, ng: &Self) -> bool {",
      "        (self - ng).abs() > 1",
      "    }",
      "    fn bs_mid_value(&self, ng: &Self) -> Self {",
      "        (self + ng) / 2",
      "    }",
      "    fn bs_into(&self) -> Self {",
      "        *self",
      "    }",
      "}",
      "impl BinarySearchOk<f64> for f64 {",
      "    fn bs_needs_next_search(&self, ng: &Self) -> bool {",
      "        (self - ng).abs() > 1.0",
      "    }",
      "    fn bs_mid_value(&self, ng: &Self) -> Self {",
      "        (self + ng) / 2.0",
      "    }",
      "    fn bs_into(&self) -> Self {",
      "        *self",
      "    }",
      "}",
      "impl BinarySearchOk<isize> for isize {",
      "    fn bs_needs_next_search(&self, ng: &Self) -> bool {",
      "        (*self - *ng).abs() > 1",
      "    }",
      "    fn bs_mid_value(&self, ng: &Self) -> Self {",
      "        (self + ng) / 2",
      "    }",
      "    fn bs_into(&self) -> Self {",
      "        *self",
      "    }",
      "}",
      "pub fn bsearch<T, Num: BinarySearchOk<T>, F>(ok: Num, ng: T, pred: F) -> Option<Num>",
      "where",
      "    F: Fn(T) -> bool,",
      "{",
      "    let orig_ok = ok;",
      "    let mut ok = ok;",
      "    let mut ng = ng;",
      "    while ok.bs_needs_next_search(&ng) {",
      "        let mid = ok.bs_mid_value(&ng);",
      "        if pred(mid.bs_into()) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid.bs_into();",
      "        }",
      "    }",
      "    if ok == orig_ok {",
      "        None",
      "    } else {",
      "        Some(ok)",
      "    }",
      "}"
    ]
  },
  "chmax": {
    "prefix": "chmax",
    "body": [
      "#[macro_export]",
      "macro_rules! chmax {",
      "    (\\$ max : expr , \\$ v : expr ) => {{",
      "        let v = \\$v;",
      "        if \\$max < v {",
      "            \\$max = v;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }};",
      "}"
    ]
  },
  "chmin": {
    "prefix": "chmin",
    "body": [
      "#[macro_export]",
      "macro_rules! chmin {",
      "    (\\$ min : expr , \\$ v : expr ) => {{",
      "        let v = \\$v;",
      "        if \\$min > v {",
      "            \\$min = v;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }};",
      "}"
    ]
  },
  "circle": {
    "prefix": "circle",
    "body": [
      "type Circle = (isize, isize, isize);",
      "pub fn is_inside_circle(c1: Circle, c2: Circle) -> bool {",
      "    let dx = c1.0 - c2.0;",
      "    let dy = c1.1 - c2.1;",
      "    let dr = c1.2 - c2.2;",
      "    dx * dx + dy * dy < dr * dr",
      "}",
      "pub fn is_outside_circle(c1: Circle, c2: Circle) -> bool {",
      "    let dx = c1.0 - c2.0;",
      "    let dy = c1.1 - c2.1;",
      "    let dr = c1.2 + c2.2;",
      "    dx * dx + dy * dy > dr * dr",
      "}"
    ]
  },
  "compress_list": {
    "prefix": "compress_list",
    "body": [
      "pub fn compress_list<T: Copy + std::cmp::PartialEq>(list: Vec<T>) -> Vec<(T, usize)> {",
      "    let mut res = Vec::new();",
      "    if list.is_empty() {",
      "        return res;",
      "    }",
      "    let mut cur_v = list[0];",
      "    let mut count = 1;",
      "    for v in list.into_iter().skip(1) {",
      "        if v == cur_v {",
      "            count += 1;",
      "        } else {",
      "            res.push((cur_v, count));",
      "            count = 1;",
      "        }",
      "        cur_v = v;",
      "    }",
      "    res.push((cur_v, count));",
      "    res",
      "}"
    ]
  },
  "compress_zahyo": {
    "prefix": "compress_zahyo",
    "body": [
      "pub fn compress_zahyo<T: Ord + std::hash::Hash + Clone>(",
      "    zahyo: &[T],",
      ") -> (",
      "    std::collections::HashMap<T, usize>,",
      "    std::collections::HashMap<usize, T>,",
      ") {",
      "    let mut set = std::collections::BTreeSet::new();",
      "    for x in zahyo {",
      "        set.insert(x.clone());",
      "    }",
      "    let mut map = std::collections::HashMap::new();",
      "    let mut inverse_map = std::collections::HashMap::new();",
      "    for (i, x) in set.into_iter().enumerate() {",
      "        map.insert(x.clone(), i);",
      "        inverse_map.insert(i, x);",
      "    }",
      "    (map, inverse_map)",
      "}"
    ]
  },
  "distance_coordinates": {
    "prefix": "distance_coordinates",
    "body": [
      "pub fn distance_coordinates(a: (f64, f64), b: (f64, f64)) -> f64 {",
      "    let h_distance = (a.0 - b.0).abs();",
      "    let v_distance = (a.1 - b.1).abs();",
      "    ((h_distance * h_distance) + (v_distance * v_distance)).sqrt()",
      "}"
    ]
  },
  "divisors": {
    "prefix": "divisors",
    "body": [
      "pub fn divisors(n: u64) -> Vec<u64> {",
      "    let mut res = Vec::new();",
      "    let mut x = 1;",
      "    while x * x <= n {",
      "        if n % x == 0 {",
      "            res.push(x);",
      "            let y = n / x;",
      "            if y != x {",
      "                res.push(y);",
      "            }",
      "        }",
      "        x += 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "#[derive(Clone)]",
      "pub struct Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    graph: Vec<Vec<(usize, Cost)>>,",
      "    vc: usize,",
      "    inf: Cost,",
      "}",
      "#[derive(Clone)]",
      "pub struct Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    from: usize,",
      "    to: usize,",
      "    cost: Cost,",
      "}",
      "impl<Cost> From<(usize, usize, Cost)> for Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    fn from(e: (usize, usize, Cost)) -> Edge<Cost> {",
      "        Edge {",
      "            from: e.0,",
      "            to: e.1,",
      "            cost: e.2,",
      "        }",
      "    }",
      "}",
      "impl<Cost> From<(usize, usize)> for Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    fn from(e: (usize, usize)) -> Edge<Cost> {",
      "        Edge {",
      "            from: e.0,",
      "            to: e.1,",
      "            cost: Cost::one(),",
      "        }",
      "    }",
      "}",
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn new_undirected(edges: Vec<impl Into<Edge<Cost>>>, vc: usize, inf: Cost) -> Self {",
      "        let mut graph = vec![Vec::new(); vc];",
      "        for e in edges {",
      "            let e = e.into();",
      "            graph[e.from].push((e.to, e.cost));",
      "            graph[e.to].push((e.from, e.cost));",
      "        }",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn new_directed(edges: Vec<impl Into<Edge<Cost>>>, vc: usize, inf: Cost) -> Self {",
      "        let mut graph = vec![Vec::new(); vc];",
      "        for e in edges {",
      "            let e = e.into();",
      "            graph[e.from].push((e.to, e.cost));",
      "        }",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn new_empty(vc: usize, inf: Cost) -> Self {",
      "        let graph = vec![Vec::new(); vc];",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn add_undirected_edge(&mut self, e: impl Into<Edge<Cost>>) {",
      "        let e = e.into();",
      "        self.graph[e.from].push((e.to, e.cost));",
      "        self.graph[e.to].push((e.from, e.cost));",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: impl Into<Edge<Cost>>) {",
      "        let e = e.into();",
      "        self.graph[e.from].push((e.to, e.cost));",
      "    }",
      "    pub fn rev(&self) -> Graph<Cost> {",
      "        let mut edges: Vec<Edge<Cost>> = Vec::new();",
      "        for u in 0..self.vc {",
      "            for &(v, w) in &self.graph[u] {",
      "                edges.push((v, u, w).into());",
      "            }",
      "        }",
      "        Self::new_directed(edges, self.vc, self.inf)",
      "    }",
      "    pub fn reachable_vertexes(&self, s: usize) -> std::collections::HashSet<usize> {",
      "        let mut visited = std::collections::HashSet::new();",
      "        let mut queue = std::collections::VecDeque::new();",
      "        visited.insert(s);",
      "        queue.push_back(s);",
      "        while let Some(u) = queue.pop_front() {",
      "            for &(v, _) in &self.graph[u] {",
      "                if visited.contains(&v) {",
      "                    continue;",
      "                }",
      "                visited.insert(v);",
      "                queue.push_back(v);",
      "            }",
      "        }",
      "        visited",
      "    }",
      "    pub fn edges<'a>(&self, u: usize) -> &Vec<(usize, Cost)> {",
      "        &self.graph[u]",
      "    }",
      "    pub fn vertex_count(&self) -> usize {",
      "        self.vc",
      "    }",
      "    fn optionalize(&self, v: Vec<Cost>) -> Vec<Option<Cost>> {",
      "        v.into_iter()",
      "            .map(|x| if x == self.inf { None } else { Some(x) })",
      "            .collect::<Vec<_>>()",
      "    }",
      "}"
    ]
  },
  "grid": {
    "prefix": "grid",
    "body": [
      "#[derive(Clone)]",
      "pub struct Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    graph: Vec<Vec<(usize, Cost)>>,",
      "    vc: usize,",
      "    inf: Cost,",
      "}",
      "#[derive(Clone)]",
      "pub struct Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    from: usize,",
      "    to: usize,",
      "    cost: Cost,",
      "}",
      "impl<Cost> From<(usize, usize, Cost)> for Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    fn from(e: (usize, usize, Cost)) -> Edge<Cost> {",
      "        Edge {",
      "            from: e.0,",
      "            to: e.1,",
      "            cost: e.2,",
      "        }",
      "    }",
      "}",
      "impl<Cost> From<(usize, usize)> for Edge<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    fn from(e: (usize, usize)) -> Edge<Cost> {",
      "        Edge {",
      "            from: e.0,",
      "            to: e.1,",
      "            cost: Cost::one(),",
      "        }",
      "    }",
      "}",
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn new_undirected(edges: Vec<impl Into<Edge<Cost>>>, vc: usize, inf: Cost) -> Self {",
      "        let mut graph = vec![Vec::new(); vc];",
      "        for e in edges {",
      "            let e = e.into();",
      "            graph[e.from].push((e.to, e.cost));",
      "            graph[e.to].push((e.from, e.cost));",
      "        }",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn new_directed(edges: Vec<impl Into<Edge<Cost>>>, vc: usize, inf: Cost) -> Self {",
      "        let mut graph = vec![Vec::new(); vc];",
      "        for e in edges {",
      "            let e = e.into();",
      "            graph[e.from].push((e.to, e.cost));",
      "        }",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn new_empty(vc: usize, inf: Cost) -> Self {",
      "        let graph = vec![Vec::new(); vc];",
      "        Self { graph, vc, inf }",
      "    }",
      "    pub fn add_undirected_edge(&mut self, e: impl Into<Edge<Cost>>) {",
      "        let e = e.into();",
      "        self.graph[e.from].push((e.to, e.cost));",
      "        self.graph[e.to].push((e.from, e.cost));",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: impl Into<Edge<Cost>>) {",
      "        let e = e.into();",
      "        self.graph[e.from].push((e.to, e.cost));",
      "    }",
      "    pub fn rev(&self) -> Graph<Cost> {",
      "        let mut edges: Vec<Edge<Cost>> = Vec::new();",
      "        for u in 0..self.vc {",
      "            for &(v, w) in &self.graph[u] {",
      "                edges.push((v, u, w).into());",
      "            }",
      "        }",
      "        Self::new_directed(edges, self.vc, self.inf)",
      "    }",
      "    pub fn reachable_vertexes(&self, s: usize) -> std::collections::HashSet<usize> {",
      "        let mut visited = std::collections::HashSet::new();",
      "        let mut queue = std::collections::VecDeque::new();",
      "        visited.insert(s);",
      "        queue.push_back(s);",
      "        while let Some(u) = queue.pop_front() {",
      "            for &(v, _) in &self.graph[u] {",
      "                if visited.contains(&v) {",
      "                    continue;",
      "                }",
      "                visited.insert(v);",
      "                queue.push_back(v);",
      "            }",
      "        }",
      "        visited",
      "    }",
      "    pub fn edges<'a>(&self, u: usize) -> &Vec<(usize, Cost)> {",
      "        &self.graph[u]",
      "    }",
      "    pub fn vertex_count(&self) -> usize {",
      "        self.vc",
      "    }",
      "    fn optionalize(&self, v: Vec<Cost>) -> Vec<Option<Cost>> {",
      "        v.into_iter()",
      "            .map(|x| if x == self.inf { None } else { Some(x) })",
      "            .collect::<Vec<_>>()",
      "    }",
      "}",
      "pub struct Grid<T>",
      "where",
      "    T: PartialEq + Eq + Copy,",
      "{",
      "    grid: Vec<Vec<T>>,",
      "    h: usize,",
      "    w: usize,",
      "    ng: Option<T>,",
      "}",
      "impl<T> Grid<T>",
      "where",
      "    T: PartialEq + Eq + Copy + Default,",
      "{",
      "    pub fn new(grid: Vec<Vec<T>>, ng: impl Into<Option<T>>) -> Self {",
      "        assert!(grid.len() > 0);",
      "        let h = grid.len();",
      "        let w = grid[0].len();",
      "        let ng: Option<T> = ng.into();",
      "        Self { grid, h, w, ng }",
      "    }",
      "    pub fn new_with_size(n: usize, m: usize) -> Self {",
      "        let grid = vec![vec![T::default(); m]; n];",
      "        Self::new(grid, None)",
      "    }",
      "    pub fn to_graph<Cost, F>(&self, inf: Cost, generator: F) -> Graph<Cost>",
      "    where",
      "        Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "        F: Fn(&Grid<T>, usize, usize) -> Vec<GridDestination<Cost>>,",
      "    {",
      "        let mut edges: Vec<Edge<Cost>> = Vec::new();",
      "        for i in 0..self.h {",
      "            for j in 0..self.w {",
      "                let from = self.vertex(i, j);",
      "                for (pos, w) in generator(&self, i, j) {",
      "                    let to = self.vertex(pos.0, pos.1);",
      "                    edges.push((from, to, w).into());",
      "                }",
      "            }",
      "        }",
      "        Graph::new_directed(edges, self.h * self.w, inf)",
      "    }",
      "    pub fn height(&self) -> usize {",
      "        self.h",
      "    }",
      "    pub fn width(&self) -> usize {",
      "        self.w",
      "    }",
      "    pub fn in_grid(&self, i: isize, j: isize) -> bool {",
      "        i >= 0 && i < self.h as isize && j >= 0 && j < self.w as isize",
      "    }",
      "    pub fn cell(&self, i: usize, j: usize) -> T {",
      "        self.grid[i][j]",
      "    }",
      "    pub fn ng(&self) -> Option<T> {",
      "        self.ng",
      "    }",
      "    pub fn vertex(&self, i: usize, j: usize) -> usize {",
      "        i * self.w + j",
      "    }",
      "    pub fn is_ok_cell(&self, i: isize, j: isize) -> bool {",
      "        if !self.in_grid(i, j) {",
      "            return false;",
      "        }",
      "        let i = i as usize;",
      "        let j = j as usize;",
      "        if self.ng().is_some() && self.cell(i, j) == self.ng().unwrap() {",
      "            return false;",
      "        }",
      "        true",
      "    }",
      "}",
      "/// 上下左右 (i, j)",
      "pub const UDLR_DIRS: [(isize, isize); 4] = [(-1, 0), (1, 0), (0, -1), (0, 1)];",
      "/// 上下左右 + 斜め (i, j)",
      "pub const ALL_DIRS: [(isize, isize); 8] = [",
      "    (-1, 0),",
      "    (-1, 1),",
      "    (0, 1),",
      "    (1, 1),",
      "    (1, 0),",
      "    (1, -1),",
      "    (0, -1),",
      "    (-1, -1),",
      "];",
      "pub type GridPos = (usize, usize);",
      "pub type GridDestination<Cost> = (GridPos, Cost);",
      "pub fn gen_grid_destinations<T, Cost>(",
      "    grid: &Grid<T>,",
      "    i: usize,",
      "    j: usize,",
      "    directions: &[(isize, isize)],",
      ") -> Vec<GridDestination<Cost>>",
      "where",
      "    T: PartialEq + Eq + Copy + Default,",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    let mut dest = Vec::new();",
      "    if grid.ng().is_some() && grid.cell(i, j) == grid.ng().unwrap() {",
      "        return dest;",
      "    }",
      "    for &(di, dj) in directions {",
      "        let new_i = i as isize + di;",
      "        let new_j = j as isize + dj;",
      "        if grid.is_ok_cell(new_i, new_j) {",
      "            let new_i = new_i as usize;",
      "            let new_j = new_j as usize;",
      "            dest.push(((new_i, new_j), Cost::one()));",
      "        }",
      "    }",
      "    dest",
      "}"
    ]
  },
  "invert_hash_map": {
    "prefix": "invert_hash_map",
    "body": [
      "pub fn invert_hash_map<K, V: std::hash::Hash + std::cmp::Eq>(",
      "    map: std::collections::HashMap<K, V>,",
      ") -> std::collections::HashMap<V, K> {",
      "    let mut res = std::collections::HashMap::new();",
      "    for (k, v) in map {",
      "        res.insert(v, k);",
      "    }",
      "    res",
      "}"
    ]
  },
  "is_bipartite_graph": {
    "prefix": "is_bipartite_graph",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn is_bipartite_graph(&self) -> bool {",
      "        let vc = self.vc;",
      "        let mut colors = vec![None; vc];",
      "        for u in 0..vc {",
      "            if colors[u].is_some() {",
      "                continue;",
      "            }",
      "            colors[u] = Some(true);",
      "            let mut que = std::collections::VecDeque::new();",
      "            que.push_back((u, true));",
      "            while let Some((u, c)) = que.pop_front() {",
      "                for &(v, _) in &self.graph[u] {",
      "                    match colors[v] {",
      "                        None => {",
      "                            let new_color = !c;",
      "                            colors[v] = Some(new_color);",
      "                            que.push_back((v, new_color));",
      "                        }",
      "                        Some(c2) => {",
      "                            if c == c2 {",
      "                                return false;",
      "                            }",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        true",
      "    }",
      "}"
    ]
  },
  "is_lear_year": {
    "prefix": "is_lear_year",
    "body": [
      "pub fn is_leap_year(n: usize) -> bool {",
      "    n % 4 == 0 && !(n % 100 == 0 && n % 400 != 0)",
      "}"
    ]
  },
  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "pub fn is_prime(n: u64) -> bool {",
      "    if n < 2 {",
      "        return false;",
      "    }",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "        i += 1;",
      "    }",
      "    true",
      "}"
    ]
  },
  "is_right_triangle": {
    "prefix": "is_right_triangle",
    "body": [
      "pub fn is_right_triangle(p1: (isize, isize), p2: (isize, isize), p3: (isize, isize)) -> bool {",
      "    let d1 = (p2.0 - p1.0).pow(2) + (p2.1 - p1.1).pow(2);",
      "    let d2 = (p2.0 - p3.0).pow(2) + (p2.1 - p3.1).pow(2);",
      "    let d3 = (p3.0 - p1.0).pow(2) + (p3.1 - p1.1).pow(2);",
      "    d1 + d2 == d3 || d1 + d3 == d2 || d2 + d3 == d1",
      "}"
    ]
  },
  "is_sections_overlapping": {
    "prefix": "is_sections_overlapping",
    "body": [
      "pub fn is_sections_overlapping(",
      "    l1: i64,",
      "    r1: i64,",
      "    l2: i64,",
      "    r2: i64,",
      "    include_side_by_side: bool,",
      ") -> bool {",
      "    assert!(l1 <= r1 && l2 <= r2);",
      "    (l1 <= l2 && l2 <= r2 && r2 <= r1)",
      "        || (l1 <= l2 && l2 < r1 && r1 <= r2)",
      "        || (l1 <= r1 && (include_side_by_side && r1 == l2) && l2 <= r2)",
      "        || (l2 <= l1 && l1 <= r1 && r1 <= r2)",
      "        || (l2 <= l1 && l1 < r2 && r2 <= r1)",
      "        || (l2 <= r2 && (include_side_by_side && r2 == l1) && l1 <= r1)",
      "}"
    ]
  },
  "is_valid_date": {
    "prefix": "is_valid_date",
    "body": [
      "pub fn is_leap_year(n: usize) -> bool {",
      "    n % 4 == 0 && !(n % 100 == 0 && n % 400 != 0)",
      "}",
      "pub fn is_valid_date(y: usize, m: usize, d: usize) -> bool {",
      "    if !(1..=12).contains(&m) {",
      "        return false;",
      "    }",
      "    let last_day_each_month = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];",
      "    let last_day = if m == 2 && is_leap_year(y) {",
      "        29",
      "    } else {",
      "        last_day_each_month[m - 1]",
      "    };",
      "    (1..=last_day).contains(&d)",
      "}"
    ]
  },
  "lazy_segment_tree": {
    "prefix": "lazy_segment_tree",
    "body": [
      "pub trait LazySegmentTreeItem<U>: Clone",
      "where",
      "    U: Clone,",
      "{",
      "    fn empty_item() -> Self;",
      "    fn append_item(&self, other: &Self) -> Self;",
      "    fn update_item(&self, v: &U) -> Self;",
      "    fn empty_update_value() -> U;",
      "    fn append_update_value(a: &U, b: &U) -> U;",
      "}",
      "#[derive(Clone, Debug)]",
      "pub struct LazySegmentTree<T, U>",
      "where",
      "    T: LazySegmentTreeItem<U>,",
      "    U: Clone,",
      "{",
      "    size: usize,",
      "    data: Vec<T>,",
      "    lazy: Vec<U>,",
      "}",
      "impl<T, U> LazySegmentTree<T, U>",
      "where",
      "    T: LazySegmentTreeItem<U> + Clone,",
      "    U: Clone,",
      "{",
      "    pub fn new(size: usize) -> Self {",
      "        let size = Self::normalize_data_size(size);",
      "        let data = vec![T::empty_item(); size * 2 - 1];",
      "        let lazy = vec![T::empty_update_value(); size * 2 - 1];",
      "        Self { size, data, lazy }",
      "    }",
      "    /// [a, b)",
      "    /// 0-origin",
      "    pub fn update(&mut self, a: usize, b: usize, v: U) {",
      "        self.execute_update(a, b, &v, 0, 0, self.size);",
      "    }",
      "    /// [a, b)",
      "    /// 0-origin",
      "    pub fn query(&mut self, a: usize, b: usize) -> T {",
      "        self.execute_query(a, b, 0, 0, self.size)",
      "    }",
      "    fn normalize_data_size(size: usize) -> usize {",
      "        let mut n = 1;",
      "        while n < size {",
      "            n *= 2;",
      "        }",
      "        n",
      "    }",
      "    fn execute_update(&mut self, a: usize, b: usize, v: &U, i: usize, l: usize, r: usize) {",
      "        self.eval(i);",
      "        if r <= a || b <= l {",
      "            return;",
      "        }",
      "        if a <= l && r <= b {",
      "            self.lazy[i] = T::append_update_value(&self.lazy[i], &v);",
      "            self.eval(i);",
      "        } else {",
      "            self.execute_update(a, b, v, i * 2 + 1, l, (l + r) / 2);",
      "            self.execute_update(a, b, v, i * 2 + 2, (l + r) / 2, r);",
      "            self.data[i] = self.data[i * 2 + 1].append_item(&self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    fn execute_query(&mut self, a: usize, b: usize, i: usize, l: usize, r: usize) -> T {",
      "        self.eval(i);",
      "        if r <= a || b <= l {",
      "            return T::empty_item();",
      "        }",
      "        if a <= l && r <= b {",
      "            self.data[i].clone()",
      "        } else {",
      "            let vl = self.execute_query(a, b, i * 2 + 1, l, (l + r) / 2);",
      "            let vr = self.execute_query(a, b, i * 2 + 2, (l + r) / 2, r);",
      "            vl.append_item(&vr)",
      "        }",
      "    }",
      "    fn eval(&mut self, i: usize) {",
      "        if i < self.size - 1 {",
      "            self.lazy[i * 2 + 1] = T::append_update_value(&self.lazy[i * 2 + 1], &self.lazy[i]);",
      "            self.lazy[i * 2 + 2] = T::append_update_value(&self.lazy[i * 2 + 2], &self.lazy[i]);",
      "        }",
      "        self.data[i] = self.data[i].update_item(&self.lazy[i]);",
      "        self.lazy[i] = T::empty_update_value();",
      "    }",
      "}",
      "impl<T, F> From<&[T]> for LazySegmentTree<T, F>",
      "where",
      "    T: LazySegmentTreeItem<F> + Clone,",
      "    F: Clone,",
      "{",
      "    fn from(values: &[T]) -> Self {",
      "        let mut st = LazySegmentTree::new(values.len());",
      "        for (i, v) in values.into_iter().enumerate() {",
      "            st.data[i + st.size - 1] = v.clone();",
      "        }",
      "        if st.size < 2 {",
      "            return st;",
      "        }",
      "        for i in (0..=(st.size - 2)).rev() {",
      "            st.data[i] = st.data[i * 2 + 1].append_item(&st.data[i * 2 + 2]);",
      "        }",
      "        st",
      "    }",
      "}",
      "impl<T, F> From<Vec<T>> for LazySegmentTree<T, F>",
      "where",
      "    T: LazySegmentTreeItem<F> + Clone,",
      "    F: Clone,",
      "{",
      "    fn from(values: Vec<T>) -> Self {",
      "        let values: &[T] = &values;",
      "        Self::from(values)",
      "    }",
      "}"
    ]
  },
  "lca": {
    "prefix": "lca",
    "body": [
      "#[derive(Clone, Debug)]",
      "pub struct SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    size: usize,",
      "    data: Vec<T>,",
      "}",
      "impl<T> SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    pub fn new(size: usize) -> Self {",
      "        let size = Self::normalize_data_size(size);",
      "        let data = vec![T::mempty(); size * 2 - 1];",
      "        Self { size, data }",
      "    }",
      "    /// 0-origin",
      "    pub fn update(&mut self, i: usize, v: T) {",
      "        let mut i = i + self.size - 1;",
      "        self.data[i] = v;",
      "        while i > 0 {",
      "            i = (i - 1) / 2;",
      "            self.data[i] = self.data[i * 2 + 1].mappend(&self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    /// 0-origin",
      "    pub fn get(&self, a: usize) -> T {",
      "        self.query(a, a + 1)",
      "    }",
      "    /// [a, b)",
      "    /// 0-origin",
      "    pub fn query(&self, a: usize, b: usize) -> T {",
      "        self.execute_query(a, b, 0, 0, self.size)",
      "    }",
      "    fn normalize_data_size(size: usize) -> usize {",
      "        let mut n = 1;",
      "        while n < size {",
      "            n *= 2;",
      "        }",
      "        n",
      "    }",
      "    fn execute_query(&self, a: usize, b: usize, i: usize, l: usize, r: usize) -> T {",
      "        if r <= a || b <= l {",
      "            return T::mempty();",
      "        }",
      "        if a <= l && r <= b {",
      "            return self.data[i].clone();",
      "        }",
      "        let vl = self.execute_query(a, b, i * 2 + 1, l, (l + r) / 2);",
      "        let vr = self.execute_query(a, b, i * 2 + 2, (l + r) / 2, r);",
      "        vl.mappend(&vr)",
      "    }",
      "}",
      "impl<T> From<&[T]> for SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    fn from(values: &[T]) -> Self {",
      "        let mut st = SegmentTree::new(values.len());",
      "        for (i, v) in values.into_iter().enumerate() {",
      "            st.data[i + st.size - 1] = v.clone();",
      "        }",
      "        if st.size < 2 {",
      "            return st;",
      "        }",
      "        for i in (0..=(st.size - 2)).rev() {",
      "            st.data[i] = st.data[i * 2 + 1].mappend(&st.data[i * 2 + 2]);",
      "        }",
      "        st",
      "    }",
      "}",
      "impl<T> From<Vec<T>> for SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    fn from(values: Vec<T>) -> Self {",
      "        let values: &[T] = &values;",
      "        Self::from(values)",
      "    }",
      "}",
      "pub trait Monoid {",
      "    fn mempty() -> Self;",
      "    fn mappend(&self, other: &Self) -> Self;",
      "}",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct LcaDepth {",
      "    depth: usize,",
      "    idx: usize,",
      "}",
      "impl Monoid for LcaDepth {",
      "    fn mempty() -> Self {",
      "        Self {",
      "            depth: std::usize::MAX,",
      "            idx: 0,",
      "        }",
      "    }",
      "    fn mappend(&self, other: &Self) -> Self {",
      "        if self.depth <= other.depth {",
      "            *self",
      "        } else {",
      "            *other",
      "        }",
      "    }",
      "}",
      "pub struct Lca {",
      "    vs: Vec<usize>,",
      "    vdepth: Vec<usize>,",
      "    vidx: Vec<usize>,",
      "    vn: usize,",
      "    st: SegmentTree<LcaDepth>,",
      "}",
      "impl Lca {",
      "    pub fn new(edges: Vec<(usize, usize)>, vn: usize, root: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for (u, v) in edges {",
      "            graph[u].push(v);",
      "            graph[v].push(u);",
      "        }",
      "        let mut vidx = vec![0; vn];",
      "        let mut vs = vec![0; vn * 2 - 1];",
      "        let mut vdepth = vec![0; vn * 2 - 1];",
      "        Self::traverse(",
      "            root,",
      "            root,",
      "            0,",
      "            &mut 0,",
      "            &graph,",
      "            &mut vidx,",
      "            &mut vs,",
      "            &mut vdepth,",
      "        );",
      "        let lca_depth = vdepth",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .map(|(i, d)| LcaDepth { depth: d, idx: i })",
      "            .collect::<Vec<_>>();",
      "        let st = SegmentTree::from(lca_depth);",
      "        Self {",
      "            vs,",
      "            vdepth,",
      "            vidx,",
      "            vn,",
      "            st,",
      "        }",
      "    }",
      "    /// 0-origin",
      "    pub fn depth(&self, u: usize) -> usize {",
      "        if u >= self.vn {",
      "            panic!(\"u >= self.vn\");",
      "        }",
      "        let i = self.vidx[u];",
      "        self.vdepth[i]",
      "    }",
      "    pub fn distance(&self, u: usize, v: usize) -> usize {",
      "        let p = self.query(u, v);",
      "        self.depth(u) + self.depth(v) - self.depth(p) * 2",
      "    }",
      "    pub fn query(&self, u: usize, v: usize) -> usize {",
      "        let ui = self.vidx[u];",
      "        let vi = self.vidx[v];",
      "        let LcaDepth { idx, .. } = self",
      "            .st",
      "            .query(std::cmp::min(ui, vi), std::cmp::max(ui, vi) + 1);",
      "        self.vs[idx]",
      "    }",
      "    fn traverse(",
      "        u: usize,",
      "        parent: usize,",
      "        depth: usize,",
      "        vid: &mut usize,",
      "        graph: &[Vec<usize>],",
      "        vids: &mut [usize],",
      "        vs: &mut [usize],",
      "        vdepth: &mut [usize],",
      "    ) {",
      "        vids[u] = *vid;",
      "        vs[*vid] = u;",
      "        vdepth[*vid] = depth;",
      "        *vid += 1;",
      "        for &v in &graph[u] {",
      "            if v != parent {",
      "                Self::traverse(v, u, depth + 1, vid, graph, vids, vs, vdepth);",
      "                vs[*vid] = u;",
      "                vdepth[*vid] = depth;",
      "                *vid += 1;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_comb": {
    "prefix": "mod_comb",
    "body": [
      "#[derive(Copy, Clone, Debug, Eq, PartialEq)]",
      "pub struct ModInt(u32);",
      "impl ModInt {",
      "    pub const MOD: u32 = 1_000_000_007;",
      "    pub fn inv(self) -> Self {",
      "        if self.0 == 0 {",
      "            panic!();",
      "        }",
      "        self.pow(Self::MOD - 2)",
      "    }",
      "    pub fn pow<T: num::Unsigned + num::PrimInt>(self, e: T) -> Self {",
      "        if e.is_zero() {",
      "            return Self::new(1);",
      "        }",
      "        let mut res = self.pow(e >> 1);",
      "        res *= res;",
      "        if e & T::one() == T::one() {",
      "            res *= self;",
      "        }",
      "        res",
      "    }",
      "    fn new(n: i64) -> Self {",
      "        let m = Self::MOD as i64;",
      "        let mut n = n % m;",
      "        if n.is_negative() {",
      "            n += m;",
      "        }",
      "        Self(n as u32)",
      "    }",
      "}",
      "macro_rules! impl_from {",
      "    (\\$ T : ty ) => {",
      "        impl From<\\$T> for ModInt {",
      "            fn from(n: \\$T) -> Self {",
      "                use std::convert::TryFrom;",
      "                Self::new(i64::try_from(n).unwrap())",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_from!(i32);",
      "impl_from!(i64);",
      "impl_from!(isize);",
      "impl_from!(u32);",
      "impl_from!(u64);",
      "impl_from!(usize);",
      "macro_rules! impl_into {",
      "    (\\$ T : ty ) => {",
      "        impl Into<\\$T> for ModInt {",
      "            fn into(self) -> \\$T {",
      "                self.0 as \\$T",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_into!(i32);",
      "impl_into!(i64);",
      "impl_into!(isize);",
      "impl_into!(u32);",
      "impl_into!(u64);",
      "impl_into!(usize);",
      "impl std::fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self::new((self.0 + rhs.0) as i64)",
      "    }",
      "}",
      "impl std::ops::AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl std::ops::Div for ModInt {",
      "    type Output = Self;",
      "    fn div(self, rhs: Self) -> Self {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl std::ops::DivAssign for ModInt {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl std::ops::Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) * (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl std::ops::Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) - (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl num::Zero for ModInt {",
      "    fn zero() -> Self {",
      "        Self::new(0)",
      "    }",
      "    fn is_zero(&self) -> bool {",
      "        *self == Self::zero()",
      "    }",
      "}",
      "impl num::One for ModInt {",
      "    fn one() -> Self {",
      "        Self::new(1)",
      "    }",
      "    fn is_one(&self) -> bool {",
      "        *self == Self::one()",
      "    }",
      "}",
      "pub struct ModComb {",
      "    n: usize,",
      "    fact: Vec<ModInt>,",
      "    ifact: Vec<ModInt>,",
      "}",
      "impl ModComb {",
      "    pub fn new(n: usize) -> Self {",
      "        assert!(n < ModInt::MOD as usize);",
      "        let mut fact = vec![ModInt::zero(); n + 1];",
      "        let mut ifact = vec![ModInt::zero(); n + 1];",
      "        fact[0] = ModInt::one();",
      "        for i in 1..=n {",
      "            fact[i] = fact[i - 1] * ModInt::from(i);",
      "        }",
      "        ifact[n] = fact[n].inv();",
      "        for i in (1..=n).rev() {",
      "            ifact[i - 1] = ifact[i] * ModInt::from(i);",
      "        }",
      "        Self { n, fact, ifact }",
      "    }",
      "    pub fn c(&self, n: usize, k: usize) -> ModInt {",
      "        assert!(n <= self.n);",
      "        if k > n {",
      "            return ModInt::zero();",
      "        }",
      "        self.fact[n] * self.ifact[k] * self.ifact[n - k]",
      "    }",
      "    pub fn p(&self, n: usize, k: usize) -> ModInt {",
      "        assert!(n <= self.n);",
      "        if k > n {",
      "            return ModInt::zero();",
      "        }",
      "        self.fact[n] * self.ifact[n - k]",
      "    }",
      "}"
    ]
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "#[derive(Copy, Clone, Debug, Eq, PartialEq)]",
      "pub struct ModInt(u32);",
      "impl ModInt {",
      "    pub const MOD: u32 = 1_000_000_007;",
      "    pub fn inv(self) -> Self {",
      "        if self.0 == 0 {",
      "            panic!();",
      "        }",
      "        self.pow(Self::MOD - 2)",
      "    }",
      "    pub fn pow<T: num::Unsigned + num::PrimInt>(self, e: T) -> Self {",
      "        if e.is_zero() {",
      "            return Self::new(1);",
      "        }",
      "        let mut res = self.pow(e >> 1);",
      "        res *= res;",
      "        if e & T::one() == T::one() {",
      "            res *= self;",
      "        }",
      "        res",
      "    }",
      "    fn new(n: i64) -> Self {",
      "        let m = Self::MOD as i64;",
      "        let mut n = n % m;",
      "        if n.is_negative() {",
      "            n += m;",
      "        }",
      "        Self(n as u32)",
      "    }",
      "}",
      "macro_rules! impl_from {",
      "    (\\$ T : ty ) => {",
      "        impl From<\\$T> for ModInt {",
      "            fn from(n: \\$T) -> Self {",
      "                use std::convert::TryFrom;",
      "                Self::new(i64::try_from(n).unwrap())",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_from!(i32);",
      "impl_from!(i64);",
      "impl_from!(isize);",
      "impl_from!(u32);",
      "impl_from!(u64);",
      "impl_from!(usize);",
      "macro_rules! impl_into {",
      "    (\\$ T : ty ) => {",
      "        impl Into<\\$T> for ModInt {",
      "            fn into(self) -> \\$T {",
      "                self.0 as \\$T",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_into!(i32);",
      "impl_into!(i64);",
      "impl_into!(isize);",
      "impl_into!(u32);",
      "impl_into!(u64);",
      "impl_into!(usize);",
      "impl std::fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self::new((self.0 + rhs.0) as i64)",
      "    }",
      "}",
      "impl std::ops::AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl std::ops::Div for ModInt {",
      "    type Output = Self;",
      "    fn div(self, rhs: Self) -> Self {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl std::ops::DivAssign for ModInt {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl std::ops::Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) * (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl std::ops::Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) - (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl num::Zero for ModInt {",
      "    fn zero() -> Self {",
      "        Self::new(0)",
      "    }",
      "    fn is_zero(&self) -> bool {",
      "        *self == Self::zero()",
      "    }",
      "}",
      "impl num::One for ModInt {",
      "    fn one() -> Self {",
      "        Self::new(1)",
      "    }",
      "    fn is_one(&self) -> bool {",
      "        *self == Self::one()",
      "    }",
      "}"
    ]
  },
  "monoid": {
    "prefix": "monoid",
    "body": [
      "pub trait Monoid {",
      "    fn mempty() -> Self;",
      "    fn mappend(&self, other: &Self) -> Self;",
      "}"
    ]
  },
  "prim": {
    "prefix": "prim",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Ord + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn prim(&self) -> Cost {",
      "        let mut used = std::collections::HashSet::new();",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        let mut res = Cost::zero();",
      "        heap.push((std::cmp::Reverse(Cost::zero()), 0));",
      "        while let Some((std::cmp::Reverse(weight), u)) = heap.pop() {",
      "            if used.contains(&u) {",
      "                continue;",
      "            }",
      "            used.insert(u);",
      "            res += weight;",
      "            for &(v, w) in &self.graph[u] {",
      "                if used.contains(&v) {",
      "                    continue;",
      "                }",
      "                heap.push((std::cmp::Reverse(w), v));",
      "            }",
      "        }",
      "        res",
      "    }",
      "}"
    ]
  },
  "prime_factor": {
    "prefix": "prime_factor",
    "body": [
      "pub fn prime_factor(n: u64) -> std::collections::HashMap<u64, u64> {",
      "    if n < 2 {",
      "        return std::collections::HashMap::new();",
      "    }",
      "    let mut res = std::collections::HashMap::new();",
      "    let mut n = n;",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        while n % i == 0 {",
      "            let c = res.entry(i).or_insert(0);",
      "            *c += 1;",
      "            n /= i;",
      "        }",
      "        i += 1;",
      "    }",
      "    if n != 1 {",
      "        res.insert(n, 1);",
      "    }",
      "    res",
      "}"
    ]
  },
  "prime_factors": {
    "prefix": "prime_factors",
    "body": [
      "pub struct PrimeFactors {",
      "    n: usize,",
      "    min_primes: Vec<usize>,",
      "}",
      "impl PrimeFactors {",
      "    pub fn new(n: usize) -> Self {",
      "        let mut min_primes = vec![0; n + 1];",
      "        for i in 2..=n {",
      "            if min_primes[i] == 0 {",
      "                let mut j = i;",
      "                while j <= n {",
      "                    min_primes[j] = i;",
      "                    j += i;",
      "                }",
      "            }",
      "        }",
      "        Self { n, min_primes }",
      "    }",
      "    pub fn prime_factor(&self, n: usize) -> std::collections::HashMap<usize, usize> {",
      "        if n < 2 {",
      "            return std::collections::HashMap::new();",
      "        }",
      "        if n > self.n {",
      "            panic!(\"n > self.n\");",
      "        }",
      "        let mut res = std::collections::HashMap::new();",
      "        let mut x = n;",
      "        while x != 1 {",
      "            let y = self.min_primes[x];",
      "            *res.entry(y).or_insert(0) += 1;",
      "            x = x / y;",
      "        }",
      "        res",
      "    }",
      "}"
    ]
  },
  "primes": {
    "prefix": "primes",
    "body": [
      "pub fn primes(n: usize) -> Vec<usize> {",
      "    if n < 2 {",
      "        return Vec::new();",
      "    }",
      "    let mut is_prime = vec![true; n + 1];",
      "    is_prime[0] = false;",
      "    is_prime[1] = false;",
      "    let mut res = Vec::new();",
      "    for i in 2..=n {",
      "        if is_prime[i] {",
      "            res.push(i);",
      "            let mut j = 2 * i;",
      "            while j <= n {",
      "                is_prime[j] = false;",
      "                j += i;",
      "            }",
      "        }",
      "    }",
      "    res",
      "}"
    ]
  },
  "radix_conversion": {
    "prefix": "radix_conversion",
    "body": [
      "pub fn convert_radix(value: &str, from_radix: u32, to_radix: u64) -> Vec<u64> {",
      "    let radix10 = u64::from_str_radix(value, from_radix).expect(\"valid radix\");",
      "    convert_radix_from10(radix10, to_radix)",
      "}",
      "pub fn convert_radix_from10(radix10: u64, to_radix: u64) -> Vec<u64> {",
      "    let mut x = radix10;",
      "    let mut ans = Vec::new();",
      "    loop {",
      "        ans.push(x % to_radix);",
      "        x /= to_radix;",
      "        if x == 0 {",
      "            break;",
      "        }",
      "    }",
      "    ans.reverse();",
      "    ans",
      "}"
    ]
  },
  "read_line": {
    "prefix": "read_line",
    "body": [
      "pub fn read_line() -> String {",
      "    let mut s = String::new();",
      "    std::io::stdin().read_line(&mut s).ok();",
      "    s.trim().to_string()",
      "}"
    ]
  },
  "rest_square_coordinates": {
    "prefix": "rest_square_coordinates",
    "body": [
      "pub fn rest_square_coordinates(a: (i32, i32), b: (i32, i32)) -> ((i32, i32), (i32, i32)) {",
      "    let c = (b.0 - b.1 + a.1, b.1 + b.0 - a.0);",
      "    let d = (c.0 - c.1 + b.1, c.1 + c.0 - b.0);",
      "    (c, d)",
      "}"
    ]
  },
  "rotate90": {
    "prefix": "rotate90",
    "body": [
      "pub fn rotate90<T: Clone>(grid: Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    assert!(!grid.is_empty());",
      "    (0..grid[0].len())",
      "        .map(|col_i| {",
      "            (0..grid.len())",
      "                .rev()",
      "                .map(|row_i| grid[row_i][col_i].clone())",
      "                .collect::<Vec<_>>()",
      "        })",
      "        .collect()",
      "}"
    ]
  },
  "rotate_coordinate": {
    "prefix": "rotate_coordinate",
    "body": [
      "pub fn rotate_coordinate(x: f64, y: f64, radian: f64) -> (f64, f64) {",
      "    let x2 = x * radian.cos() - y * radian.sin();",
      "    let y2 = x * radian.sin() + y * radian.cos();",
      "    (x2, y2)",
      "}"
    ]
  },
  "scc": {
    "prefix": "scc",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn scc(&self) -> Vec<Vec<usize>> {",
      "        let vc = self.vc;",
      "        let mut id = 0;",
      "        let mut ids = vec![0; vc];",
      "        let mut used = vec![false; vc];",
      "        for u in 0..vc {",
      "            if used[u] {",
      "                continue;",
      "            }",
      "            self.scc_dfs1(u, &mut id, &mut ids, &mut used);",
      "        }",
      "        let mut u_with_id = ids.into_iter().enumerate().collect::<Vec<_>>();",
      "        u_with_id.sort_by_key(|(_, id)| -(*id as isize));",
      "        let rev_graph = self.rev();",
      "        let mut groups = Vec::new();",
      "        let mut used = vec![false; vc];",
      "        for (u, _) in u_with_id {",
      "            if used[u] {",
      "                continue;",
      "            }",
      "            let mut group = Vec::new();",
      "            rev_graph.scc_dfs2(u, &mut group, &mut used);",
      "            groups.push(group);",
      "        }",
      "        groups",
      "    }",
      "    fn scc_dfs1(&self, u: usize, id: &mut usize, ids: &mut Vec<usize>, used: &mut Vec<bool>) {",
      "        used[u] = true;",
      "        for &(v, _) in &self.graph[u] {",
      "            if used[v] {",
      "                continue;",
      "            }",
      "            self.scc_dfs1(v, id, ids, used);",
      "        }",
      "        *id += 1;",
      "        ids[u] = *id;",
      "    }",
      "    fn scc_dfs2(&self, u: usize, group: &mut Vec<usize>, used: &mut Vec<bool>) {",
      "        group.push(u);",
      "        used[u] = true;",
      "        for &(v, _) in &self.graph[u] {",
      "            if used[v] {",
      "                continue;",
      "            }",
      "            self.scc_dfs2(v, group, used);",
      "        }",
      "    }",
      "}"
    ]
  },
  "sections_overlapping_size": {
    "prefix": "sections_overlapping_size",
    "body": [
      "pub fn sections_overlapping_size(l1: i64, r1: i64, l2: i64, r2: i64) -> i64 {",
      "    assert!(l1 <= r1 && l2 <= r2);",
      "    if l1 <= l2 && l2 <= r2 && r2 <= r1 {",
      "        return r2 - l2 + 1;",
      "    }",
      "    if l1 <= l2 && l2 <= r1 && r1 <= r2 {",
      "        return r1 - l2 + 1;",
      "    }",
      "    if l2 <= l1 && l1 <= r1 && r1 <= r2 {",
      "        return r1 - l1 + 1;",
      "    }",
      "    if l2 <= l1 && l1 <= r2 && r2 <= r1 {",
      "        return r2 - l1 + 1;",
      "    }",
      "    0",
      "}"
    ]
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "pub trait Monoid {",
      "    fn mempty() -> Self;",
      "    fn mappend(&self, other: &Self) -> Self;",
      "}",
      "#[derive(Clone, Debug)]",
      "pub struct SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    size: usize,",
      "    data: Vec<T>,",
      "}",
      "impl<T> SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    pub fn new(size: usize) -> Self {",
      "        let size = Self::normalize_data_size(size);",
      "        let data = vec![T::mempty(); size * 2 - 1];",
      "        Self { size, data }",
      "    }",
      "    /// 0-origin",
      "    pub fn update(&mut self, i: usize, v: T) {",
      "        let mut i = i + self.size - 1;",
      "        self.data[i] = v;",
      "        while i > 0 {",
      "            i = (i - 1) / 2;",
      "            self.data[i] = self.data[i * 2 + 1].mappend(&self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    /// 0-origin",
      "    pub fn get(&self, a: usize) -> T {",
      "        self.query(a, a + 1)",
      "    }",
      "    /// [a, b)",
      "    /// 0-origin",
      "    pub fn query(&self, a: usize, b: usize) -> T {",
      "        self.execute_query(a, b, 0, 0, self.size)",
      "    }",
      "    fn normalize_data_size(size: usize) -> usize {",
      "        let mut n = 1;",
      "        while n < size {",
      "            n *= 2;",
      "        }",
      "        n",
      "    }",
      "    fn execute_query(&self, a: usize, b: usize, i: usize, l: usize, r: usize) -> T {",
      "        if r <= a || b <= l {",
      "            return T::mempty();",
      "        }",
      "        if a <= l && r <= b {",
      "            return self.data[i].clone();",
      "        }",
      "        let vl = self.execute_query(a, b, i * 2 + 1, l, (l + r) / 2);",
      "        let vr = self.execute_query(a, b, i * 2 + 2, (l + r) / 2, r);",
      "        vl.mappend(&vr)",
      "    }",
      "}",
      "impl<T> From<&[T]> for SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    fn from(values: &[T]) -> Self {",
      "        let mut st = SegmentTree::new(values.len());",
      "        for (i, v) in values.into_iter().enumerate() {",
      "            st.data[i + st.size - 1] = v.clone();",
      "        }",
      "        if st.size < 2 {",
      "            return st;",
      "        }",
      "        for i in (0..=(st.size - 2)).rev() {",
      "            st.data[i] = st.data[i * 2 + 1].mappend(&st.data[i * 2 + 2]);",
      "        }",
      "        st",
      "    }",
      "}",
      "impl<T> From<Vec<T>> for SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    fn from(values: Vec<T>) -> Self {",
      "        let values: &[T] = &values;",
      "        Self::from(values)",
      "    }",
      "}"
    ]
  },
  "shortest_path": {
    "prefix": "shortest_path",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Ord + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn shortest_path(&self, start: usize) -> Vec<Option<Cost>> {",
      "        let mut cost_list = vec![self.inf; self.vc];",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        cost_list[start] = Cost::zero();",
      "        heap.push((std::cmp::Reverse(Cost::zero()), start));",
      "        while let Some((std::cmp::Reverse(cost), u)) = heap.pop() {",
      "            if cost > cost_list[u] {",
      "                continue;",
      "            }",
      "            for &(v, w) in &self.graph[u] {",
      "                let new_cost = cost + w;",
      "                if new_cost < cost_list[v] {",
      "                    heap.push((std::cmp::Reverse(new_cost), v));",
      "                    cost_list[v] = new_cost;",
      "                }",
      "            }",
      "        }",
      "        self.optionalize(cost_list)",
      "    }",
      "}"
    ]
  },
  "shortest_path01": {
    "prefix": "shortest_path01",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn shortest_path_01(&self, start: usize) -> Vec<Option<Cost>> {",
      "        let mut cost_list = vec![self.inf; self.vc];",
      "        let mut que = std::collections::VecDeque::new();",
      "        cost_list[start] = Cost::zero();",
      "        que.push_front((start, Cost::zero()));",
      "        while let Some((u, cost)) = que.pop_front() {",
      "            if cost > cost_list[u] {",
      "                continue;",
      "            }",
      "            for &(v, w) in &self.graph[u] {",
      "                if !w.is_zero() && !w.is_one() {",
      "                    panic!(\"weight is not 01\");",
      "                }",
      "                let new_cost = cost + w;",
      "                if new_cost < cost_list[v] {",
      "                    cost_list[v] = new_cost;",
      "                    if w.is_zero() {",
      "                        que.push_front((v, new_cost));",
      "                    } else {",
      "                        que.push_back((v, new_cost));",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        self.optionalize(cost_list)",
      "    }",
      "}"
    ]
  },
  "shortest_path1": {
    "prefix": "shortest_path1",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn shortest_path_1(&self, start: usize) -> Vec<Option<Cost>> {",
      "        let mut cost_list = vec![None; self.vc];",
      "        let mut que = std::collections::VecDeque::new();",
      "        cost_list[start] = Some(Cost::zero());",
      "        que.push_back(start);",
      "        while let Some(u) = que.pop_front() {",
      "            for &(v, w) in &self.graph[u] {",
      "                if !w.is_one() {",
      "                    panic!(\"weight is not 1\");",
      "                }",
      "                if cost_list[v].is_some() {",
      "                    continue;",
      "                }",
      "                let new_cost = cost_list[u].unwrap() + Cost::one();",
      "                cost_list[v] = Some(new_cost);",
      "                que.push_back(v);",
      "            }",
      "        }",
      "        cost_list",
      "    }",
      "}"
    ]
  },
  "traveling_salesman": {
    "prefix": "traveling_salesman",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn traveling_salesman(&self, start: usize) -> Cost {",
      "        let mut dp = vec![vec![None; self.vc]; 1 << self.vc];",
      "        let fin = (1 << self.vc) - 1;",
      "        self.traveling_salesman_impl(0, start, &mut dp, start, fin)",
      "    }",
      "    fn traveling_salesman_impl(",
      "        &self,",
      "        state: usize,",
      "        u: usize,",
      "        dp: &mut [Vec<Option<Cost>>],",
      "        start: usize,",
      "        fin: usize,",
      "    ) -> Cost {",
      "        if let Some(res) = dp[state][u] {",
      "            return res;",
      "        }",
      "        if state == fin && u == start {",
      "            let res = Cost::zero();",
      "            dp[state][u] = Some(res);",
      "            return res;",
      "        }",
      "        let mut res = self.inf;",
      "        for &(v, cost) in &self.graph[u] {",
      "            let new_state = state | (1 << v);",
      "            if new_state != state {",
      "                let new_cost = self.traveling_salesman_impl(new_state, v, dp, start, fin) + cost;",
      "                if new_cost < res {",
      "                    res = new_cost;",
      "                }",
      "            }",
      "        }",
      "        dp[state][u] = Some(res);",
      "        res",
      "    }",
      "}"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "pub struct UnionFind {",
      "    n: usize,",
      "    root: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    size: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        let root = (0..n).collect();",
      "        let rank = vec![0; n];",
      "        let size = vec![1; n];",
      "        Self {",
      "            n,",
      "            root,",
      "            rank,",
      "            size,",
      "        }",
      "    }",
      "    pub fn find(&mut self, x: usize) -> usize {",
      "        assert!(x < self.n);",
      "        if self.root[x] == x {",
      "            x",
      "        } else {",
      "            let root = self.find(self.root[x]);",
      "            self.root[x] = root;",
      "            root",
      "        }",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) {",
      "        assert!(x < self.n && y < self.n);",
      "        let x_root = self.find(x);",
      "        let y_root = self.find(y);",
      "        if x_root == y_root {",
      "            return;",
      "        }",
      "        if self.rank[x_root] < self.rank[y_root] {",
      "            self.root[x_root] = y_root;",
      "            self.size[y_root] += self.size[x_root];",
      "        } else {",
      "            self.root[y_root] = x_root;",
      "            self.size[x_root] += self.size[y_root];",
      "            if self.rank[x_root] == self.rank[y_root] {",
      "                self.rank[x_root] += 1;",
      "            }",
      "        }",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        assert!(x < self.n);",
      "        let x_root = self.find(x);",
      "        self.size[x_root]",
      "    }",
      "    pub fn is_same(&mut self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.n && y < self.n);",
      "        self.find(x) == self.find(y)",
      "    }",
      "    pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "        let mut groups = std::collections::HashMap::new();",
      "        for x in 0..self.n {",
      "            let k = self.find(x);",
      "            groups.entry(k).or_insert(Vec::new()).push(x);",
      "        }",
      "        groups.values().cloned().collect::<Vec<_>>()",
      "    }",
      "}"
    ]
  },
  "warshall_floyd": {
    "prefix": "warshall_floyd",
    "body": [
      "impl<Cost> Graph<Cost>",
      "where",
      "    Cost: PartialOrd + Copy + num::traits::NumAssign,",
      "{",
      "    pub fn warshall_floyd(&self) -> Vec<Vec<Option<Cost>>> {",
      "        let vc = self.vc;",
      "        let mut cost_list = vec![vec![self.inf; vc]; vc];",
      "        for u in 0..vc {",
      "            for &(v, w) in &self.graph[u] {",
      "                cost_list[u][v] = w;",
      "            }",
      "        }",
      "        for i in 0..vc {",
      "            cost_list[i][i] = Cost::zero();",
      "        }",
      "        for k in 0..vc {",
      "            for i in 0..vc {",
      "                for j in 0..vc {",
      "                    let new_cost = cost_list[i][k] + cost_list[k][j];",
      "                    if new_cost < cost_list[i][j] {",
      "                        cost_list[i][j] = new_cost;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        cost_list",
      "            .into_iter()",
      "            .map(|v| self.optionalize(v))",
      "            .collect::<Vec<_>>()",
      "    }",
      "}"
    ]
  },
  "zalgo": {
    "prefix": "zalgo",
    "body": [
      "pub fn zalgo(s: &[char]) -> Vec<usize> {",
      "    if s.len() == 0 {",
      "        return Vec::new();",
      "    }",
      "    let len = s.len();",
      "    let mut res = vec![0; len];",
      "    res[0] = len;",
      "    let mut i = 1;",
      "    let mut j = 0;",
      "    while i < len {",
      "        while i + j < len && s[j] == s[i + j] {",
      "            j += 1;",
      "        }",
      "        res[i] = j;",
      "        if j == 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut k = 1;",
      "        while i + k < len && k + res[k] < j {",
      "            res[i + k] = res[k];",
      "            k += 1;",
      "        }",
      "        i += k;",
      "        j -= k;",
      "    }",
      "    res",
      "}"
    ]
  }
}
