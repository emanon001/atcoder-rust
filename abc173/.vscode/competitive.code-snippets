{
  "ascii_chars": {
    "prefix": "ascii_chars",
    "body": [
      "pub fn make_ascii_lowercase_chars() -> Vec<char> {",
      "    let base = 0x61;",
      "    make_chars(base..base + 26)",
      "}",
      "pub fn make_ascii_uppercase_chars() -> Vec<char> {",
      "    let base = 0x41;",
      "    make_chars(base..base + 26)",
      "}",
      "fn make_chars(range: std::ops::Range<u8>) -> Vec<char> {",
      "    range.into_iter().map(char::from).collect::<Vec<_>>()",
      "}",
      "pub fn rotate_ascii_lowercase_char(ch: char, n: isize) -> char {",
      "    assert!(ch.is_ascii_lowercase());",
      "    rotate_char(ch, n, 0x61, 26)",
      "}",
      "pub fn rotate_ascii_uppercase_char(ch: char, n: isize) -> char {",
      "    assert!(ch.is_ascii_uppercase());",
      "    rotate_char(ch, n, 0x41, 26)",
      "}",
      "fn rotate_char(ch: char, n: isize, base: u8, m: u8) -> char {",
      "    let m = m as isize;",
      "    let ch_pos = ch as u8 - base;",
      "    let offset = if n >= 0 {",
      "        (ch_pos as isize + n) % m",
      "    } else {",
      "        (m - (ch_pos as isize - n.abs()).abs() % m) % m",
      "    } as u8;",
      "    char::from(base + offset)",
      "}"
    ]
  },
  "bit": {
    "prefix": "bit",
    "body": [
      "pub struct Bit {",
      "    n: usize,",
      "    data: Vec<i64>,",
      "}",
      "impl Bit {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            n,",
      "            data: vec![0; n + 1],",
      "        }",
      "    }",
      "    pub fn add(&mut self, i: usize, x: i64) {",
      "        if i >= self.n {",
      "            panic!();",
      "        }",
      "        let mut i = i + 1;",
      "        while i <= self.n {",
      "            self.data[i] += x;",
      "            i += ((i as isize) & -(i as isize)) as usize;",
      "        }",
      "    }",
      "    pub fn sum(&self, i: usize) -> i64 {",
      "        if i > self.n {",
      "            panic!();",
      "        }",
      "        let mut i = i;",
      "        let mut res = 0;",
      "        while i > 0 {",
      "            res += self.data[i];",
      "            i -= ((i as isize) & -(i as isize)) as usize;",
      "        }",
      "        res",
      "    }",
      "}"
    ]
  },
  "bsearch": {
    "prefix": "bsearch",
    "body": [
      "pub fn bsearch<F>(ok: i64, ng: i64, pred: F) -> Option<i64>",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    let orig_ok = ok;",
      "    let mut ok = ok;",
      "    let mut ng = ng;",
      "    while (ok - ng).abs() > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if pred(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    if ok == orig_ok {",
      "        None",
      "    } else {",
      "        Some(ok)",
      "    }",
      "}"
    ]
  },
  "divisors": {
    "prefix": "divisors",
    "body": [
      "pub fn divisors(n: u64) -> Vec<u64> {",
      "    let mut res = Vec::new();",
      "    let mut x = 1;",
      "    while x * x <= n {",
      "        if n % x == 0 {",
      "            res.push(x);",
      "            let y = n / x;",
      "            if y != x {",
      "                res.push(y);",
      "            }",
      "        }",
      "        x += 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "#[derive(Clone)]",
      "pub struct UnweightedGraph {",
      "    graph: WeightedGraph,",
      "}",
      "pub type UnweightedEdge = (usize, usize);",
      "impl UnweightedGraph {",
      "    pub fn new(edges: &[UnweightedEdge], vn: usize) -> Self {",
      "        let edges = Self::to_weighted_edges(&edges);",
      "        let graph = WeightedGraph::new(&edges, vn);",
      "        Self { graph }",
      "    }",
      "    pub fn new_directed(edges: &[UnweightedEdge], vn: usize) -> Self {",
      "        let edges = Self::to_weighted_edges(&edges);",
      "        let graph = WeightedGraph::new_directed(&edges, vn);",
      "        Self { graph }",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: UnweightedEdge) {",
      "        self.graph.add_directed_edge((e.0, e.1, 1));",
      "    }",
      "    pub fn add_edge(&mut self, e: UnweightedEdge) {",
      "        self.graph.add_edge((e.0, e.1, 1));",
      "    }",
      "    pub fn shortest_path(&self, start: usize) -> Vec<Option<usize>> {",
      "        let mut cost_list = vec![None; self.graph.vn];",
      "        let mut que = std::collections::VecDeque::new();",
      "        cost_list[start] = Some(0);",
      "        que.push_back(start);",
      "        while let Some(u) = que.pop_front() {",
      "            for &(v, _) in &self.graph.graph[u] {",
      "                if cost_list[v].is_some() {",
      "                    continue;",
      "                }",
      "                let new_cost = cost_list[u].unwrap() + 1;",
      "                cost_list[v] = Some(new_cost);",
      "                que.push_back(v);",
      "            }",
      "        }",
      "        cost_list",
      "    }",
      "    pub fn to_weighted_graph(&self) -> WeightedGraph {",
      "        self.graph.clone()",
      "    }",
      "    fn to_weighted_edges(edges: &[UnweightedEdge]) -> Vec<WeightedEdge> {",
      "        edges",
      "            .into_iter()",
      "            .map(|(u, v)| (*u, *v, 1))",
      "            .collect::<Vec<_>>()",
      "    }",
      "}",
      "#[derive(Clone)]",
      "pub struct WeightedGraph {",
      "    graph: Vec<Vec<(usize, i64)>>,",
      "    vn: usize,",
      "}",
      "pub type WeightedEdge = (usize, usize, i64);",
      "impl WeightedGraph {",
      "    const INF: i64 = 1 << 60;",
      "    pub fn new(edges: &[WeightedEdge], vn: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for &(u, v, w) in edges {",
      "            graph[u].push((v, w));",
      "            graph[v].push((u, w));",
      "        }",
      "        Self { graph, vn }",
      "    }",
      "    pub fn new_directed(edges: &[WeightedEdge], vn: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for &(u, v, w) in edges {",
      "            graph[u].push((v, w));",
      "        }",
      "        Self { graph, vn }",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: WeightedEdge) {",
      "        self.graph[e.0].push((e.1, e.2));",
      "    }",
      "    pub fn add_edge(&mut self, e: WeightedEdge) {",
      "        self.graph[e.0].push((e.1, e.2));",
      "        self.graph[e.1].push((e.0, e.2));",
      "    }",
      "    pub fn bellman_ford(&self, s: usize) -> Option<Vec<Option<i64>>> {",
      "        let vn = self.vn;",
      "        let inf = Self::INF;",
      "        let mut cost_list = vec![inf; vn];",
      "        cost_list[s] = 0;",
      "        for c in 0..vn {",
      "            for u in 0..vn {",
      "                for &(v, w) in &self.graph[u] {",
      "                    if cost_list[u] == inf {",
      "                        continue;",
      "                    }",
      "                    let new_cost = cost_list[u] + w;",
      "                    if new_cost < cost_list[v] {",
      "                        cost_list[v] = new_cost;",
      "                        if c == vn - 1 {",
      "                            return None;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        Some(self.optionalize(cost_list))",
      "    }",
      "    pub fn prim(&self) -> i64 {",
      "        let mut used = std::collections::HashSet::new();",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        let mut res = 0_i64;",
      "        heap.push(std::cmp::Reverse((0_i64, 0)));",
      "        while let Some(std::cmp::Reverse((weight, u))) = heap.pop() {",
      "            if used.contains(&u) {",
      "                continue;",
      "            }",
      "            used.insert(u);",
      "            res += weight;",
      "            for &(v, w) in &self.graph[u] {",
      "                if used.contains(&v) {",
      "                    continue;",
      "                }",
      "                heap.push(std::cmp::Reverse((w, v)));",
      "            }",
      "        }",
      "        res",
      "    }",
      "    pub fn reachable_vertexes(&self, s: usize) -> std::collections::HashSet<usize> {",
      "        let mut visited = std::collections::HashSet::new();",
      "        let mut queue = std::collections::VecDeque::new();",
      "        visited.insert(s);",
      "        queue.push_back(s);",
      "        while let Some(u) = queue.pop_front() {",
      "            for &(v, _) in &self.graph[u] {",
      "                if visited.contains(&v) {",
      "                    continue;",
      "                }",
      "                visited.insert(v);",
      "                queue.push_back(v);",
      "            }",
      "        }",
      "        visited",
      "    }",
      "    pub fn rev(&self) -> WeightedGraph {",
      "        let mut edges = Vec::new();",
      "        for u in 0..self.vn {",
      "            for &(v, w) in &self.graph[u] {",
      "                edges.push((v, u, w));",
      "            }",
      "        }",
      "        Self::new_directed(&edges, self.vn)",
      "    }",
      "    pub fn shortest_path(&self, start: usize) -> Vec<Option<i64>> {",
      "        let mut cost_list = vec![Self::INF; self.vn];",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        cost_list[start] = 0;",
      "        heap.push(std::cmp::Reverse((0_i64, start)));",
      "        while let Some(std::cmp::Reverse((cost, u))) = heap.pop() {",
      "            if cost > cost_list[u] {",
      "                continue;",
      "            }",
      "            for &(v, w) in &self.graph[u] {",
      "                let new_cost = cost + w;",
      "                if new_cost < cost_list[v] {",
      "                    heap.push(std::cmp::Reverse((new_cost, v)));",
      "                    cost_list[v] = new_cost;",
      "                }",
      "            }",
      "        }",
      "        self.optionalize(cost_list)",
      "    }",
      "    pub fn warshall_floyd(&self) -> Vec<Vec<Option<i64>>> {",
      "        let inf = Self::INF;",
      "        let vn = self.vn;",
      "        let mut cost_list = vec![vec![inf; vn]; vn];",
      "        for u in 0..vn {",
      "            for &(v, w) in &self.graph[u] {",
      "                cost_list[u][v] = w;",
      "            }",
      "        }",
      "        for i in 0..vn {",
      "            cost_list[i][i] = 0;",
      "        }",
      "        for k in 0..vn {",
      "            for i in 0..vn {",
      "                for j in 0..vn {",
      "                    cost_list[i][j] =",
      "                        std::cmp::min(cost_list[i][j], cost_list[i][k] + cost_list[k][j]);",
      "                }",
      "            }",
      "        }",
      "        cost_list",
      "            .into_iter()",
      "            .map(|v| self.optionalize(v))",
      "            .collect::<Vec<_>>()",
      "    }",
      "    fn optionalize(&self, v: Vec<i64>) -> Vec<Option<i64>> {",
      "        v.into_iter()",
      "            .map(|x| if x == Self::INF { None } else { Some(x) })",
      "            .collect::<Vec<_>>()",
      "    }",
      "}"
    ]
  },
  "grid": {
    "prefix": "grid",
    "body": [
      "#[derive(Clone)]",
      "pub struct UnweightedGraph {",
      "    graph: WeightedGraph,",
      "}",
      "pub type UnweightedEdge = (usize, usize);",
      "impl UnweightedGraph {",
      "    pub fn new(edges: &[UnweightedEdge], vn: usize) -> Self {",
      "        let edges = Self::to_weighted_edges(&edges);",
      "        let graph = WeightedGraph::new(&edges, vn);",
      "        Self { graph }",
      "    }",
      "    pub fn new_directed(edges: &[UnweightedEdge], vn: usize) -> Self {",
      "        let edges = Self::to_weighted_edges(&edges);",
      "        let graph = WeightedGraph::new_directed(&edges, vn);",
      "        Self { graph }",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: UnweightedEdge) {",
      "        self.graph.add_directed_edge((e.0, e.1, 1));",
      "    }",
      "    pub fn add_edge(&mut self, e: UnweightedEdge) {",
      "        self.graph.add_edge((e.0, e.1, 1));",
      "    }",
      "    pub fn shortest_path(&self, start: usize) -> Vec<Option<usize>> {",
      "        let mut cost_list = vec![None; self.graph.vn];",
      "        let mut que = std::collections::VecDeque::new();",
      "        cost_list[start] = Some(0);",
      "        que.push_back(start);",
      "        while let Some(u) = que.pop_front() {",
      "            for &(v, _) in &self.graph.graph[u] {",
      "                if cost_list[v].is_some() {",
      "                    continue;",
      "                }",
      "                let new_cost = cost_list[u].unwrap() + 1;",
      "                cost_list[v] = Some(new_cost);",
      "                que.push_back(v);",
      "            }",
      "        }",
      "        cost_list",
      "    }",
      "    pub fn to_weighted_graph(&self) -> WeightedGraph {",
      "        self.graph.clone()",
      "    }",
      "    fn to_weighted_edges(edges: &[UnweightedEdge]) -> Vec<WeightedEdge> {",
      "        edges",
      "            .into_iter()",
      "            .map(|(u, v)| (*u, *v, 1))",
      "            .collect::<Vec<_>>()",
      "    }",
      "}",
      "#[derive(Clone)]",
      "pub struct WeightedGraph {",
      "    graph: Vec<Vec<(usize, i64)>>,",
      "    vn: usize,",
      "}",
      "pub type WeightedEdge = (usize, usize, i64);",
      "impl WeightedGraph {",
      "    const INF: i64 = 1 << 60;",
      "    pub fn new(edges: &[WeightedEdge], vn: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for &(u, v, w) in edges {",
      "            graph[u].push((v, w));",
      "            graph[v].push((u, w));",
      "        }",
      "        Self { graph, vn }",
      "    }",
      "    pub fn new_directed(edges: &[WeightedEdge], vn: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for &(u, v, w) in edges {",
      "            graph[u].push((v, w));",
      "        }",
      "        Self { graph, vn }",
      "    }",
      "    pub fn add_directed_edge(&mut self, e: WeightedEdge) {",
      "        self.graph[e.0].push((e.1, e.2));",
      "    }",
      "    pub fn add_edge(&mut self, e: WeightedEdge) {",
      "        self.graph[e.0].push((e.1, e.2));",
      "        self.graph[e.1].push((e.0, e.2));",
      "    }",
      "    pub fn bellman_ford(&self, s: usize) -> Option<Vec<Option<i64>>> {",
      "        let vn = self.vn;",
      "        let inf = Self::INF;",
      "        let mut cost_list = vec![inf; vn];",
      "        cost_list[s] = 0;",
      "        for c in 0..vn {",
      "            for u in 0..vn {",
      "                for &(v, w) in &self.graph[u] {",
      "                    if cost_list[u] == inf {",
      "                        continue;",
      "                    }",
      "                    let new_cost = cost_list[u] + w;",
      "                    if new_cost < cost_list[v] {",
      "                        cost_list[v] = new_cost;",
      "                        if c == vn - 1 {",
      "                            return None;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        Some(self.optionalize(cost_list))",
      "    }",
      "    pub fn prim(&self) -> i64 {",
      "        let mut used = std::collections::HashSet::new();",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        let mut res = 0_i64;",
      "        heap.push(std::cmp::Reverse((0_i64, 0)));",
      "        while let Some(std::cmp::Reverse((weight, u))) = heap.pop() {",
      "            if used.contains(&u) {",
      "                continue;",
      "            }",
      "            used.insert(u);",
      "            res += weight;",
      "            for &(v, w) in &self.graph[u] {",
      "                if used.contains(&v) {",
      "                    continue;",
      "                }",
      "                heap.push(std::cmp::Reverse((w, v)));",
      "            }",
      "        }",
      "        res",
      "    }",
      "    pub fn reachable_vertexes(&self, s: usize) -> std::collections::HashSet<usize> {",
      "        let mut visited = std::collections::HashSet::new();",
      "        let mut queue = std::collections::VecDeque::new();",
      "        visited.insert(s);",
      "        queue.push_back(s);",
      "        while let Some(u) = queue.pop_front() {",
      "            for &(v, _) in &self.graph[u] {",
      "                if visited.contains(&v) {",
      "                    continue;",
      "                }",
      "                visited.insert(v);",
      "                queue.push_back(v);",
      "            }",
      "        }",
      "        visited",
      "    }",
      "    pub fn rev(&self) -> WeightedGraph {",
      "        let mut edges = Vec::new();",
      "        for u in 0..self.vn {",
      "            for &(v, w) in &self.graph[u] {",
      "                edges.push((v, u, w));",
      "            }",
      "        }",
      "        Self::new_directed(&edges, self.vn)",
      "    }",
      "    pub fn shortest_path(&self, start: usize) -> Vec<Option<i64>> {",
      "        let mut cost_list = vec![Self::INF; self.vn];",
      "        let mut heap = std::collections::BinaryHeap::new();",
      "        cost_list[start] = 0;",
      "        heap.push(std::cmp::Reverse((0_i64, start)));",
      "        while let Some(std::cmp::Reverse((cost, u))) = heap.pop() {",
      "            if cost > cost_list[u] {",
      "                continue;",
      "            }",
      "            for &(v, w) in &self.graph[u] {",
      "                let new_cost = cost + w;",
      "                if new_cost < cost_list[v] {",
      "                    heap.push(std::cmp::Reverse((new_cost, v)));",
      "                    cost_list[v] = new_cost;",
      "                }",
      "            }",
      "        }",
      "        self.optionalize(cost_list)",
      "    }",
      "    pub fn warshall_floyd(&self) -> Vec<Vec<Option<i64>>> {",
      "        let inf = Self::INF;",
      "        let vn = self.vn;",
      "        let mut cost_list = vec![vec![inf; vn]; vn];",
      "        for u in 0..vn {",
      "            for &(v, w) in &self.graph[u] {",
      "                cost_list[u][v] = w;",
      "            }",
      "        }",
      "        for i in 0..vn {",
      "            cost_list[i][i] = 0;",
      "        }",
      "        for k in 0..vn {",
      "            for i in 0..vn {",
      "                for j in 0..vn {",
      "                    cost_list[i][j] =",
      "                        std::cmp::min(cost_list[i][j], cost_list[i][k] + cost_list[k][j]);",
      "                }",
      "            }",
      "        }",
      "        cost_list",
      "            .into_iter()",
      "            .map(|v| self.optionalize(v))",
      "            .collect::<Vec<_>>()",
      "    }",
      "    fn optionalize(&self, v: Vec<i64>) -> Vec<Option<i64>> {",
      "        v.into_iter()",
      "            .map(|x| if x == Self::INF { None } else { Some(x) })",
      "            .collect::<Vec<_>>()",
      "    }",
      "}",
      "pub struct Grid {",
      "    grid: Vec<Vec<char>>,",
      "    h: usize,",
      "    w: usize,",
      "    ng_char: char,",
      "    dirs: Vec<(isize, isize)>,",
      "}",
      "pub type VertexTable = std::collections::HashMap<(usize, usize), usize>;",
      "impl Grid {",
      "    #[allow(dead_code)]",
      "    const UDLR_DIRS: [(isize, isize); 4] = [(-1, 0), (1, 0), (0, -1), (0, 1)];",
      "    #[allow(dead_code)]",
      "    const ALL_DIRS: [(isize, isize); 8] = [",
      "        (-1, 0),",
      "        (-1, 1),",
      "        (0, 1),",
      "        (1, 1),",
      "        (1, 0),",
      "        (1, -1),",
      "        (0, -1),",
      "        (-1, -1),",
      "    ];",
      "    pub fn new(grid: &[Vec<char>], ng_char: char, dirs: &[(isize, isize)]) -> Self {",
      "        assert!(grid.len() > 0);",
      "        let grid = grid.into_iter().cloned().collect::<Vec<_>>();",
      "        let h = grid.len();",
      "        let w = grid[0].len();",
      "        let dirs = dirs.into_iter().copied().collect::<Vec<_>>();",
      "        Self {",
      "            grid,",
      "            h,",
      "            w,",
      "            ng_char,",
      "            dirs,",
      "        }",
      "    }",
      "    pub fn to_graph(&self) -> (UnweightedGraph, VertexTable) {",
      "        let mut edges = Vec::new();",
      "        let mut vertex_table = std::collections::HashMap::new();",
      "        let mut v = 0;",
      "        for i in 0..self.h {",
      "            for j in 0..self.w {",
      "                if self.grid[i][j] == self.ng_char {",
      "                    continue;",
      "                }",
      "                let from = self.gen_vertex_if_needed((i, j), &mut vertex_table, &mut v);",
      "                for &(di, dj) in &self.dirs {",
      "                    let new_i = i as isize + di;",
      "                    let new_j = j as isize + dj;",
      "                    if new_i < 0",
      "                        || new_i >= self.h as isize",
      "                        || new_j < 0",
      "                        || new_j >= self.w as isize",
      "                    {",
      "                        continue;",
      "                    }",
      "                    let new_i = new_i as usize;",
      "                    let new_j = new_j as usize;",
      "                    if self.grid[new_i][new_j] == self.ng_char {",
      "                        continue;",
      "                    }",
      "                    let to = self.gen_vertex_if_needed((new_i, new_j), &mut vertex_table, &mut v);",
      "                    edges.push((from, to));",
      "                }",
      "            }",
      "        }",
      "        let graph = UnweightedGraph::new_directed(&edges, vertex_table.len());",
      "        (graph, vertex_table)",
      "    }",
      "    fn gen_vertex_if_needed(",
      "        &self,",
      "        pos: (usize, usize),",
      "        vertex_table: &mut VertexTable,",
      "        cur_v: &mut usize,",
      "    ) -> usize {",
      "        if let Some(&v) = vertex_table.get(&pos) {",
      "            return v;",
      "        } else {",
      "            let v = *cur_v;",
      "            vertex_table.insert(pos, *cur_v);",
      "            *cur_v += 1;",
      "            return v;",
      "        };",
      "    }",
      "}"
    ]
  },
  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "pub fn is_prime(n: u64) -> bool {",
      "    if n < 2 {",
      "        return false;",
      "    }",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "        i += 1;",
      "    }",
      "    true",
      "}"
    ]
  },
  "lca": {
    "prefix": "lca",
    "body": [
      "pub trait Monoid {",
      "    fn empty() -> Self;",
      "    fn append(&self, other: &Self) -> Self;",
      "}",
      "pub struct SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    size: usize,",
      "    data: Vec<T>,",
      "}",
      "impl<T> SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    pub fn new(size: usize) -> Self {",
      "        let size = Self::normalize_data_size(size);",
      "        let data = vec![T::empty(); size * 2 - 1];",
      "        Self { size, data }",
      "    }",
      "    pub fn from_slice(values: &[T]) -> Self {",
      "        let mut st = SegmentTree::new(values.len());",
      "        for (i, v) in values.into_iter().enumerate() {",
      "            st.data[i + st.size - 1] = v.clone();",
      "        }",
      "        if st.size < 2 {",
      "            return st;",
      "        }",
      "        for i in (0..=(st.size - 2)).rev() {",
      "            st.data[i] = st.data[i * 2 + 1].append(&st.data[i * 2 + 2]);",
      "        }",
      "        st",
      "    }",
      "    pub fn update(&mut self, i: usize, v: T) {",
      "        let mut i = i + self.size - 1;",
      "        self.data[i] = v;",
      "        while i > 0 {",
      "            i = (i - 1) / 2;",
      "            self.data[i] = self.data[i * 2 + 1].append(&self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    pub fn query(&self, a: usize, b: usize) -> T {",
      "        self.execute_query(a, b, 0, 0, self.size)",
      "    }",
      "    fn normalize_data_size(size: usize) -> usize {",
      "        let mut n = 1;",
      "        while n < size {",
      "            n *= 2;",
      "        }",
      "        n",
      "    }",
      "    fn execute_query(&self, a: usize, b: usize, i: usize, l: usize, r: usize) -> T {",
      "        if r <= a || b <= l {",
      "            return T::empty();",
      "        }",
      "        if a <= l && r <= b {",
      "            return self.data[i].clone();",
      "        }",
      "        let vl = self.execute_query(a, b, i * 2 + 1, l, (l + r) / 2);",
      "        let vr = self.execute_query(a, b, i * 2 + 2, (l + r) / 2, r);",
      "        vl.append(&vr)",
      "    }",
      "}",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct LcaDepth {",
      "    depth: usize,",
      "    idx: usize,",
      "}",
      "impl Monoid for LcaDepth {",
      "    fn empty() -> Self {",
      "        Self {",
      "            depth: std::usize::MAX,",
      "            idx: 0,",
      "        }",
      "    }",
      "    fn append(&self, other: &Self) -> Self {",
      "        if self.depth <= other.depth {",
      "            *self",
      "        } else {",
      "            *other",
      "        }",
      "    }",
      "}",
      "pub struct Lca {",
      "    vs: Vec<usize>,",
      "    vdepth: Vec<usize>,",
      "    vidx: Vec<usize>,",
      "    vn: usize,",
      "    st: SegmentTree<LcaDepth>,",
      "}",
      "impl Lca {",
      "    pub fn new(edges: &[(usize, usize)], vn: usize, root: usize) -> Self {",
      "        let mut graph = vec![Vec::new(); vn];",
      "        for &(u, v) in edges {",
      "            graph[u].push(v);",
      "            graph[v].push(u);",
      "        }",
      "        let mut vidx = vec![0; vn];",
      "        let mut vs = vec![0; vn * 2 - 1];",
      "        let mut vdepth = vec![0; vn * 2 - 1];",
      "        Self::traverse(",
      "            root,",
      "            root,",
      "            0,",
      "            &mut 0,",
      "            &graph,",
      "            &mut vidx,",
      "            &mut vs,",
      "            &mut vdepth,",
      "        );",
      "        let lca_depth = vdepth",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .map(|(i, d)| LcaDepth { depth: d, idx: i })",
      "            .collect::<Vec<_>>();",
      "        let st = SegmentTree::from_slice(&lca_depth);",
      "        Self {",
      "            vs,",
      "            vdepth,",
      "            vidx,",
      "            vn,",
      "            st,",
      "        }",
      "    }",
      "    pub fn depth(&self, u: usize) -> usize {",
      "        if u >= self.vn {",
      "            panic!(\"u >= self.vn\");",
      "        }",
      "        let i = self.vidx[u];",
      "        self.vdepth[i]",
      "    }",
      "    pub fn query(&self, u: usize, v: usize) -> usize {",
      "        let ui = self.vidx[u];",
      "        let vi = self.vidx[v];",
      "        let LcaDepth { idx, .. } = self",
      "            .st",
      "            .query(std::cmp::min(ui, vi), std::cmp::max(ui, vi) + 1);",
      "        self.vs[idx]",
      "    }",
      "    fn traverse(",
      "        u: usize,",
      "        parent: usize,",
      "        depth: usize,",
      "        vid: &mut usize,",
      "        graph: &[Vec<usize>],",
      "        vids: &mut [usize],",
      "        vs: &mut [usize],",
      "        vdepth: &mut [usize],",
      "    ) {",
      "        vids[u] = *vid;",
      "        vs[*vid] = u;",
      "        vdepth[*vid] = depth;",
      "        *vid += 1;",
      "        for &v in &graph[u] {",
      "            if v != parent {",
      "                Self::traverse(v, u, depth + 1, vid, graph, vids, vs, vdepth);",
      "                vs[*vid] = u;",
      "                vdepth[*vid] = depth;",
      "                *vid += 1;",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_comb": {
    "prefix": "mod_comb",
    "body": [
      "#[derive(Copy, Clone, Debug, Eq, PartialEq)]",
      "pub struct ModInt(u32);",
      "impl ModInt {",
      "    pub const MOD: u32 = 1_000_000_007;",
      "    pub fn inv(self) -> Self {",
      "        if self.0 == 0 {",
      "            panic!();",
      "        }",
      "        self.pow(Self::MOD - 2)",
      "    }",
      "    pub fn one() -> Self {",
      "        Self(1)",
      "    }",
      "    pub fn pow(self, e: u32) -> Self {",
      "        if e == 0 {",
      "            return Self::new(1);",
      "        }",
      "        let mut res = self.pow(e >> 1);",
      "        res *= res;",
      "        if e & 1 == 1 {",
      "            res *= self;",
      "        }",
      "        res",
      "    }",
      "    pub fn zero() -> Self {",
      "        Self(0)",
      "    }",
      "    fn new(n: i64) -> Self {",
      "        let mut n = n % (Self::MOD as i64);",
      "        if n.is_negative() {",
      "            n += Self::MOD as i64;",
      "        }",
      "        Self(n as u32)",
      "    }",
      "}",
      "impl From<i32> for ModInt {",
      "    fn from(n: i32) -> Self {",
      "        ModInt::from(n as i64)",
      "    }",
      "}",
      "impl From<i64> for ModInt {",
      "    fn from(n: i64) -> Self {",
      "        Self::new(n)",
      "    }",
      "}",
      "impl From<isize> for ModInt {",
      "    fn from(n: isize) -> Self {",
      "        ModInt::from(n as i64)",
      "    }",
      "}",
      "impl From<u32> for ModInt {",
      "    fn from(n: u32) -> Self {",
      "        ModInt::from(n as u64)",
      "    }",
      "}",
      "impl From<u64> for ModInt {",
      "    fn from(n: u64) -> Self {",
      "        Self::new(n as i64)",
      "    }",
      "}",
      "impl From<usize> for ModInt {",
      "    fn from(n: usize) -> Self {",
      "        ModInt::from(n as u64)",
      "    }",
      "}",
      "impl Into<i32> for ModInt {",
      "    fn into(self) -> i32 {",
      "        self.0 as i32",
      "    }",
      "}",
      "impl Into<i64> for ModInt {",
      "    fn into(self) -> i64 {",
      "        self.0 as i64",
      "    }",
      "}",
      "impl Into<isize> for ModInt {",
      "    fn into(self) -> isize {",
      "        self.0 as isize",
      "    }",
      "}",
      "impl Into<u32> for ModInt {",
      "    fn into(self) -> u32 {",
      "        self.0",
      "    }",
      "}",
      "impl Into<u64> for ModInt {",
      "    fn into(self) -> u64 {",
      "        self.0 as u64",
      "    }",
      "}",
      "impl Into<usize> for ModInt {",
      "    fn into(self) -> usize {",
      "        self.0 as usize",
      "    }",
      "}",
      "impl std::fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self::new((self.0 + rhs.0) as i64)",
      "    }",
      "}",
      "impl std::ops::AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl std::ops::Div for ModInt {",
      "    type Output = Self;",
      "    fn div(self, rhs: Self) -> Self {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl std::ops::DivAssign for ModInt {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl std::ops::Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) * (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl std::ops::Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) - (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "pub struct ModComb {",
      "    max: usize,",
      "    fac: Vec<ModInt>,",
      "    finv: Vec<ModInt>,",
      "}",
      "impl ModComb {",
      "    pub fn new(max: usize) -> Self {",
      "        let mut fac = vec![ModInt::zero(); max + 1];",
      "        let mut finv = vec![ModInt::zero(); max + 1];",
      "        let mut inv = vec![ModInt::zero(); max + 1];",
      "        fac[0] = ModInt::one();",
      "        fac[1] = ModInt::one();",
      "        finv[0] = ModInt::one();",
      "        finv[1] = ModInt::one();",
      "        inv[1] = ModInt::one();",
      "        let modulo = ModInt::MOD as usize;",
      "        for i in 2..=max {",
      "            fac[i] = fac[i - 1] * ModInt::from(i);",
      "            inv[i] =",
      "                ModInt::from(ModInt::from(modulo) - (inv[modulo % i] * ModInt::from(modulo / i)));",
      "            finv[i] = finv[i - 1] * inv[i]",
      "        }",
      "        Self { max, fac, finv }",
      "    }",
      "    pub fn comb(&self, n: usize, k: usize) -> ModInt {",
      "        if n > self.max {",
      "            panic!();",
      "        }",
      "        if n < k {",
      "            return ModInt::zero();",
      "        }",
      "        self.fac[n] * self.finv[k] * self.finv[n - k]",
      "    }",
      "}"
    ]
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "#[derive(Copy, Clone, Debug, Eq, PartialEq)]",
      "pub struct ModInt(u32);",
      "impl ModInt {",
      "    pub const MOD: u32 = 1_000_000_007;",
      "    pub fn inv(self) -> Self {",
      "        if self.0 == 0 {",
      "            panic!();",
      "        }",
      "        self.pow(Self::MOD - 2)",
      "    }",
      "    pub fn one() -> Self {",
      "        Self(1)",
      "    }",
      "    pub fn pow(self, e: u32) -> Self {",
      "        if e == 0 {",
      "            return Self::new(1);",
      "        }",
      "        let mut res = self.pow(e >> 1);",
      "        res *= res;",
      "        if e & 1 == 1 {",
      "            res *= self;",
      "        }",
      "        res",
      "    }",
      "    pub fn zero() -> Self {",
      "        Self(0)",
      "    }",
      "    fn new(n: i64) -> Self {",
      "        let mut n = n % (Self::MOD as i64);",
      "        if n.is_negative() {",
      "            n += Self::MOD as i64;",
      "        }",
      "        Self(n as u32)",
      "    }",
      "}",
      "impl From<i32> for ModInt {",
      "    fn from(n: i32) -> Self {",
      "        ModInt::from(n as i64)",
      "    }",
      "}",
      "impl From<i64> for ModInt {",
      "    fn from(n: i64) -> Self {",
      "        Self::new(n)",
      "    }",
      "}",
      "impl From<isize> for ModInt {",
      "    fn from(n: isize) -> Self {",
      "        ModInt::from(n as i64)",
      "    }",
      "}",
      "impl From<u32> for ModInt {",
      "    fn from(n: u32) -> Self {",
      "        ModInt::from(n as u64)",
      "    }",
      "}",
      "impl From<u64> for ModInt {",
      "    fn from(n: u64) -> Self {",
      "        Self::new(n as i64)",
      "    }",
      "}",
      "impl From<usize> for ModInt {",
      "    fn from(n: usize) -> Self {",
      "        ModInt::from(n as u64)",
      "    }",
      "}",
      "impl Into<i32> for ModInt {",
      "    fn into(self) -> i32 {",
      "        self.0 as i32",
      "    }",
      "}",
      "impl Into<i64> for ModInt {",
      "    fn into(self) -> i64 {",
      "        self.0 as i64",
      "    }",
      "}",
      "impl Into<isize> for ModInt {",
      "    fn into(self) -> isize {",
      "        self.0 as isize",
      "    }",
      "}",
      "impl Into<u32> for ModInt {",
      "    fn into(self) -> u32 {",
      "        self.0",
      "    }",
      "}",
      "impl Into<u64> for ModInt {",
      "    fn into(self) -> u64 {",
      "        self.0 as u64",
      "    }",
      "}",
      "impl Into<usize> for ModInt {",
      "    fn into(self) -> usize {",
      "        self.0 as usize",
      "    }",
      "}",
      "impl std::fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self::new((self.0 + rhs.0) as i64)",
      "    }",
      "}",
      "impl std::ops::AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl std::ops::Div for ModInt {",
      "    type Output = Self;",
      "    fn div(self, rhs: Self) -> Self {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl std::ops::DivAssign for ModInt {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl std::ops::Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) * (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl std::ops::Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        Self::new((self.0 as i64) - (rhs.0 as i64))",
      "    }",
      "}",
      "impl std::ops::SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        *self = *self - rhs;",
      "    }",
      "}"
    ]
  },
  "prime_factor": {
    "prefix": "prime_factor",
    "body": [
      "pub fn prime_factor(n: u64) -> std::collections::HashMap<u64, u64> {",
      "    if n < 2 {",
      "        return std::collections::HashMap::new();",
      "    }",
      "    let mut res = std::collections::HashMap::new();",
      "    let mut n = n;",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        while n % i == 0 {",
      "            let c = res.entry(i).or_insert(0);",
      "            *c += 1;",
      "            n /= i;",
      "        }",
      "        i += 1;",
      "    }",
      "    if n != 1 {",
      "        res.insert(n, 1);",
      "    }",
      "    res",
      "}"
    ]
  },
  "primes": {
    "prefix": "primes",
    "body": [
      "pub fn primes(n: usize) -> Vec<usize> {",
      "    if n < 2 {",
      "        return Vec::new();",
      "    }",
      "    let mut is_prime = vec![true; n + 1];",
      "    is_prime[0] = false;",
      "    is_prime[1] = false;",
      "    let mut res = Vec::new();",
      "    for i in 2..=n {",
      "        if is_prime[i] {",
      "            res.push(i);",
      "            let mut j = 2 * i;",
      "            while j <= n {",
      "                is_prime[j] = false;",
      "                j += i;",
      "            }",
      "        }",
      "    }",
      "    res",
      "}"
    ]
  },
  "rest_square_coordinates": {
    "prefix": "rest_square_coordinates",
    "body": [
      "pub fn rest_square_coordinates(a: (i32, i32), b: (i32, i32)) -> ((i32, i32), (i32, i32)) {",
      "    let c = (b.0 - b.1 + a.1, b.1 + b.0 - a.0);",
      "    let d = (c.0 - c.1 + b.1, c.1 + c.0 - b.0);",
      "    (c, d)",
      "}"
    ]
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "pub trait Monoid {",
      "    fn empty() -> Self;",
      "    fn append(&self, other: &Self) -> Self;",
      "}",
      "pub struct SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    size: usize,",
      "    data: Vec<T>,",
      "}",
      "impl<T> SegmentTree<T>",
      "where",
      "    T: Monoid + Clone,",
      "{",
      "    pub fn new(size: usize) -> Self {",
      "        let size = Self::normalize_data_size(size);",
      "        let data = vec![T::empty(); size * 2 - 1];",
      "        Self { size, data }",
      "    }",
      "    pub fn from_slice(values: &[T]) -> Self {",
      "        let mut st = SegmentTree::new(values.len());",
      "        for (i, v) in values.into_iter().enumerate() {",
      "            st.data[i + st.size - 1] = v.clone();",
      "        }",
      "        if st.size < 2 {",
      "            return st;",
      "        }",
      "        for i in (0..=(st.size - 2)).rev() {",
      "            st.data[i] = st.data[i * 2 + 1].append(&st.data[i * 2 + 2]);",
      "        }",
      "        st",
      "    }",
      "    pub fn update(&mut self, i: usize, v: T) {",
      "        let mut i = i + self.size - 1;",
      "        self.data[i] = v;",
      "        while i > 0 {",
      "            i = (i - 1) / 2;",
      "            self.data[i] = self.data[i * 2 + 1].append(&self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    pub fn query(&self, a: usize, b: usize) -> T {",
      "        self.execute_query(a, b, 0, 0, self.size)",
      "    }",
      "    fn normalize_data_size(size: usize) -> usize {",
      "        let mut n = 1;",
      "        while n < size {",
      "            n *= 2;",
      "        }",
      "        n",
      "    }",
      "    fn execute_query(&self, a: usize, b: usize, i: usize, l: usize, r: usize) -> T {",
      "        if r <= a || b <= l {",
      "            return T::empty();",
      "        }",
      "        if a <= l && r <= b {",
      "            return self.data[i].clone();",
      "        }",
      "        let vl = self.execute_query(a, b, i * 2 + 1, l, (l + r) / 2);",
      "        let vr = self.execute_query(a, b, i * 2 + 2, (l + r) / 2, r);",
      "        vl.append(&vr)",
      "    }",
      "}"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "pub struct UnionFind {",
      "    n: usize,",
      "    root: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    size: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        let root = (0..n).collect();",
      "        let rank = vec![0; n];",
      "        let size = vec![1; n];",
      "        Self {",
      "            n,",
      "            root,",
      "            rank,",
      "            size,",
      "        }",
      "    }",
      "    pub fn find(&mut self, x: usize) -> usize {",
      "        if x >= self.n {",
      "            panic!();",
      "        }",
      "        if self.root[x] == x {",
      "            x",
      "        } else {",
      "            let root = self.find(self.root[x]);",
      "            self.root[x] = root;",
      "            root",
      "        }",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) {",
      "        if x >= self.n || y >= self.n {",
      "            panic!();",
      "        }",
      "        let x_root = self.find(x);",
      "        let y_root = self.find(y);",
      "        if x_root == y_root {",
      "            return;",
      "        }",
      "        if self.rank[x_root] < self.rank[y_root] {",
      "            self.root[x_root] = y_root;",
      "            self.size[y_root] += self.size[x_root];",
      "        } else {",
      "            self.root[y_root] = x_root;",
      "            self.size[x_root] += self.size[y_root];",
      "            if self.rank[x_root] == self.rank[y_root] {",
      "                self.rank[x_root] += 1;",
      "            }",
      "        }",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        if x >= self.n {",
      "            panic!();",
      "        }",
      "        let x_root = self.find(x);",
      "        self.size[x_root]",
      "    }",
      "    pub fn is_same(&mut self, x: usize, y: usize) -> bool {",
      "        if x >= self.n || y >= self.n {",
      "            panic!();",
      "        }",
      "        self.find(x) == self.find(y)",
      "    }",
      "}"
    ]
  },
  "zalgo": {
    "prefix": "zalgo",
    "body": [
      "pub fn zalgo(s: &[char]) -> Vec<usize> {",
      "    if s.len() == 0 {",
      "        return Vec::new();",
      "    }",
      "    let len = s.len();",
      "    let mut res = vec![0; len];",
      "    res[0] = len;",
      "    let mut i = 1;",
      "    let mut j = 0;",
      "    while i < len {",
      "        while i + j < len && s[j] == s[i + j] {",
      "            j += 1;",
      "        }",
      "        res[i] = j;",
      "        if j == 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut k = 1;",
      "        while i + k < len && k + res[k] < j {",
      "            res[i + k] = res[k];",
      "            k += 1;",
      "        }",
      "        i += k;",
      "        j -= k;",
      "    }",
      "    res",
      "}"
    ]
  }
}
